/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <cstdint>
#include <cstdlib>
#include <vector>
export module utils;
import logic;

using namespace logic;

export std::vector<std::vector<Bytes>> channelBlocksData = {
        {
                // 0  1    2    3
                // 0-7 8-15 16-23 24-31
                {0x0, 0x1, 0x2, 0x3}, // CH0
                {0x1, 0x2, 0x3, 0x4}, // CH1
                {0x2, 0x3, 0x4, 0x5}, // CH2
                {0x3, 0x4, 0x5, 0x6}, // CH3
        },

        {
                // 4  5    6    7
                // 32-39 40-47 48-55 56-63
                {0x4, 0x5, 0x6, 0x7}, // CH0
                {0x5, 0x6, 0x7, 0x8}, // CH1
                {0x6, 0x7, 0x8, 0x9}, // CH2
                {0x7, 0x8, 0x9, 0xa}, // CH3
        },
        {
                // 8  9    10   11
                // 64-71 72-79 80-87 88-95
                {0x8, 0x9, 0xa, 0xb}, // CH0
                {0x9, 0xa, 0xb, 0xc}, // CH1
                {0xa, 0xb, 0xc, 0xd}, // CH2
                {0xb, 0xc, 0xd, 0xe}, // CH3
        },
};

export auto getChannelBlockData (size_t idx) { return channelBlocksData.at (idx); }

// Prepare generators suitable for continuous work. DemoDevice does the same.
std::vector<Square> generators (16);

// Simulate a block from DemoDevice (16 channels square signals).
export auto generateDemoDeviceBlock (uint8_t channelsNumber = 16, size_t samplesPerChannel = 8192)
{
        std::vector<Bytes> channels (channelsNumber);

        size_t cnt{};
        for (auto &chan : channels) {
                chan = generators.at (cnt) (cnt + 1, cnt + 1, samplesPerChannel);
                ++cnt;
        }

        return channels;
};

/// Yes.
export auto vectorize = [] (auto const &sp) {
        std::vector<bool> dreadedVector;

        for (bool b : sp) {
                dreadedVector.push_back (b);
        }
        return dreadedVector;
};
