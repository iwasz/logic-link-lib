/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <libusb.h>
#include <mutex>
export module logic.peripheral:input;
import logic.data;
import logic.core;

namespace logic {

/**
 * Responsibilities:
 * - Running some kind of an event loop for a communiaction channel like USB.
 *
 * Notes:
 * This interface is used (only?) when invoking its run method via std::async, which
 * in turn is generic, and doesn't require an (object oriented) interface. Despite this
 * I somehow feel better having it.
 *
 * Configurations (ORed):
 * - Session + deviceA (single tab, single device)
 * - Session + deviceA + deviceB (single tab, multiple devices)
 * - SessionA + deviceA... , SessionB + DeviceB
 */
export struct IInput {
        IInput () = default;
        IInput (IInput const &) = default;
        IInput &operator= (IInput const &) = default;
        IInput (IInput &&) noexcept = default;
        IInput &operator= (IInput &&) noexcept = default;
        virtual ~IInput () = default;

        /**
         * Blocking acquisition and event listener method, that pushes the data at the
         * end of the `data` queue and observes the hotplug events.
         */
        virtual void run () = 0;

        /**
         * Breaks the run loop.
         */
        virtual void kill () = 0;
};

/**
 * A helper that has a notion of the EventQueue.
 */
export class AbstractInput : public IInput {
public:
        AbstractInput (EventQueue *eventQueue) : eventQueue_{eventQueue} {}
        EventQueue *eventQueue () { return eventQueue_; }

private:
        EventQueue *eventQueue_;
};

} // namespace logic
