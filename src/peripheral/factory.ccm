/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <libusb.h>
#include <memory>
#include <set>
#include <string>
export module logic.peripheral:device.factory;
import :device;
import :input.usb.async;
import :input.demo;
import logic.core;

namespace logic {

export class Factory {
public:
        Factory (EventQueue *eventQueue) : eventQueue_{eventQueue}, usb_{eventQueue} {}
        Factory (Factory const &) = delete;
        Factory &operator= (Factory const &) = delete;
        Factory (Factory &&) = delete;
        Factory &operator= (Factory &&) = delete;
        ~Factory () = default;

        /**
         * Create an IDevice instance for the first connected device or wait.
         */
        std::shared_ptr<IDevice> create () const;

        /**
         * Create a device by name - waits (blocks) if no matching device was connected.
         * If name is empty, delegates to create().
         */
        std::shared_ptr<IDevice> create (std::string const &name) const;

        /**
         * Returns a list of all detected devices that are currently connected.
         * DOES NOT block.
         */
        std::set<std::string> getConnectedDevices () const;

        /*
         * TODO this has to be removed. This is left vecause right now I use it for
         * the async future argument both in cli and gui apps. Some more advanced task
         * management should get implemented instead.
         */
        UsbAsyncInput &usb () { return usb_; }

private:
        EventQueue *eventQueue_;
        UsbAsyncInput usb_;
};

/****************************************************************************/

std::set<std::string> Factory::getConnectedDevices () const
{
        std::set<std::string> set;
        // set = usbFactory.getConnectedDevices ();
        return set;
}

/****************************************************************************/

// std::set<std::string> Factory::getConnectedDevices () const
// {
//         std::vector<std::pair<int, int>> vps;
//         eventQueue_->visitAlarms<UsbConnectedAlarm> ([&vps] (int v, int p) { vps.emplace_back (v, p); });
//         auto notEmptyString = [] (auto const &s) { return !s.empty (); };
//         return vps | std::views::transform ([this] (auto const &p) { return vidPidToName (p); }) | std::views::filter (notEmptyString)
//                 | std::ranges::to<std::set<std::string>> ();
// }

}; // namespace logic