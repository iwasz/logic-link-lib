/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/error.hh"
#include "common/params.hh"
#include "common/stats.hh"
#include <any>
#include <functional>
#include <libusb.h>
#include <memory>
#include <unordered_set>
export module logic.peripheral:device;
import logic.core;
import logic.data;

namespace logic {

/**
 * IDevice concrete classes are responsible of configuring the devices (for instance
 * by sending USB control requests) and initial decompresing and decoding.
 */
export struct IDevice {
        IDevice () = default;
        IDevice (IDevice const &) = default;
        IDevice &operator= (IDevice const &) = default;
        IDevice (IDevice &&) noexcept = default;
        IDevice &operator= (IDevice &&) noexcept = default;
        virtual ~IDevice () = default;

        /// Model name
        virtual std::string name () const = 0;
        /// Hardware revision as described in https://github.com/iwasz/logic-link-doc/blob/main/Versioning.md
        virtual std::string hwVersion () const = 0;
        /// Firmware version.
        virtual std::string fwVersion () const = 0;
        /// Device serial number flashed into every device.
        virtual std::string deviceSerial () const = 0;
        /// MCU serial number or other immutable SN.
        virtual std::string mcuSerial () const = 0;

        /**
         * Set acquisition parameters like number of channels and the
         * sample rate.
         */
        virtual void writeAcquisitionParams (common::acq::Params const &params, bool legacy = false) = 0;
        virtual common::acq::Params readAcquisitionParams () const = 0;

        /**
         * Configure buffer sizes intrinsic to the device - hence the std::any
         * interface. Concreet classes are responsible for converting the argument
         * and using it.
         */
        // virtual void configureTransmission (std::any const &params) = 0;

        /**
         * Sets the session and informs an IInput object assigned to this device
         * that the start was requested. Real request gets sent from onStart.
         */
        virtual void start (Queue<RawCompressedBlock> *queue, IBackend *backend) = 0;
        virtual void stop () = 0;
        virtual void run () = 0;

        /// Simply if it's running the acquisition or not.
        virtual bool running () const = 0;

        /// Separate method, because we can heve an error while running, or when stoped.
        enum class State : uint8_t { ok, error };
        virtual State state () const = 0;

        /**
         * Get device statistics - speciffic to the device itself and the USB interface.
         * If this was to be a member of the IInput interface, it would have to have better,
         * more generic interface.
         */
        virtual common::usb::Stats getStats () = 0;

        /**
         * Get error list from the device if any.
         */
        virtual std::unordered_set<logs::Code> getErrors () = 0;
        virtual void clearErrors () = 0;
};

/**
 * Raised when new device gents detected. Universal alarm for all
 * kinds of devices (be it USB, or demo or others).
 */
export class DeviceAlarm : public AbstractAlarm<DeviceAlarm> {
public:
        explicit DeviceAlarm (std::shared_ptr<IDevice> const &device) : device_{device} {}

        void execute (std::any const &func) const override
        {
                auto f = std::any_cast<std::function<void (std::shared_ptr<IDevice> const &)>> (func);
                f (device_);
        }

        std::size_t hash () const override { return std::hash<std::size_t>{}(size_t (device_.get ())); }

        // std::shared_ptr<IDevice> device () const { return device_; };

private:
        /*
         * Pointer is shared because internal factories can delete an IDevice instance
         * upon device disconnection or error.
         */
        std::shared_ptr<IDevice> device_;
};

/**
 * As name suggestes, gets emitted when status chnages.
 */
export class DeviceStatusAlarm : public AbstractAlarm<DeviceStatusAlarm> {
public:
        DeviceStatusAlarm (IDevice const *device, bool running, IDevice::State status) : device_{device}, running_{running}, status_{status} {}

        void execute (std::any const &func) const override
        {
                auto f = std::any_cast<std::function<void (IDevice const *device, bool running, IDevice::State status)>> (func);
                f (device_, running_, status_);
        }

        std::size_t hash () const override { return size_t (device_) ^ (size_t (status_) << 1) ^ (size_t (running_) << 3); }

private:
        IDevice const *device_;
        bool running_;
        IDevice::State status_;
};
} // namespace logic