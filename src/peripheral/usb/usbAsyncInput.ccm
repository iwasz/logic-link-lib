/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <atomic>
#include <future>
#include <libusb.h>
#include <memory>
#include <unordered_map>
#include <vector>
export module logic.peripheral:input.usb.async;
import :device.factory.usb;

namespace logic {
export class UsbDevice;
export class UsbAsyncInput;

/**
 * Abstraction over asynchronous libusb implementation, with a (blocking) event
 * processing loop meant to be used from a separate thread. Remember that synchronous
 * libusb implementation is based on the asyc one, so in order to gain full control
 * async was choosen as more low level. Another aspect is the hot-swap and multiple
 * USB devices - from this point of view synchronous variant is much harder to use.
 */
export class UsbAsyncInput : public AbstractInput {
public:
        friend struct UsbHandleInternal;

        /**
         * Construct a new UsbAsync object and initializes the libusb.
         */
        UsbAsyncInput (EventQueue *eventQueue);
        UsbAsyncInput (UsbAsyncInput const &) = delete;
        UsbAsyncInput &operator= (UsbAsyncInput const &) = delete;
        UsbAsyncInput (UsbAsyncInput &&) noexcept = delete;
        UsbAsyncInput &operator= (UsbAsyncInput &&) noexcept = delete;

        /**
         * Gracefully de-inits the libusb.
         */
        ~UsbAsyncInput () noexcept override;

        void run () override;
        void kill () override
        {
                running_.store (false);
                handlesCVar.notify_all ();
        }

private:
        void acquireLoop ();
        void analyzeLoop ();

        static int hotplugCallback (struct libusb_context * /* ctx */, struct libusb_device *dev, libusb_hotplug_event event, void *userData);
        libusb_hotplug_callback_handle hotplugCallbackHandle{};
        std::atomic_bool running_ = true;

        using UsbHandles = std::unordered_map<libusb_device const *, std::pair<libusb_device_handle *, std::shared_ptr<UsbDevice>>>;
        UsbHandles handles;
        std::mutex mutex; // Protects the `handles` collection.
        std::condition_variable handlesCVar;

        std::future<void> acquireFuture;
        std::future<void> analyzeFuture;

        // TODO.
        /// Number of bytes received so far irrespective of the buffer size.
        // size_t receivedB () const { return allTransferedB; }
        // TimePoint globalStart;
        // TimePoint globalStop;
        // size_t allTransferedB{};

        UsbFactory usbFactory;
};

} // namespace logic