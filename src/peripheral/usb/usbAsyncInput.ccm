/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <atomic>
#include <libusb.h>
#include <memory>
#include <unordered_map>
export module logic.peripheral:input.usb.async;
import :device.factory.usb;

namespace logic {
export struct UsbDevice;
export class UsbAsyncInput;

/**
 * Abstraction over asynchronous libusb implementation, with a (blocking) event
 * processing loop meant to be used from a separate thread. Remember that synchronous
 * libusb implementation is based on the asyc one, so in order to gain full control
 * async was choosen as more low level. Another aspect is the hot-swap and multiple
 * USB devices - from this point of view synchronous variant is much harder to use.
 */
export class UsbAsyncInput : public AbstractInput {
public:
        friend struct UsbHandleInternal;

        /**
         * Construct a new UsbAsync object and initializes the libusb.
         */
        UsbAsyncInput (EventQueue *eventQueue);
        UsbAsyncInput (UsbAsyncInput const &) = delete;
        UsbAsyncInput &operator= (UsbAsyncInput const &) = delete;
        UsbAsyncInput (UsbAsyncInput &&) noexcept = delete;
        UsbAsyncInput &operator= (UsbAsyncInput &&) noexcept = delete;

        /**
         * Gracefully de-inits the libusb.
         */
        ~UsbAsyncInput () override;

        /*--------------------------------------------------------------------------*/

        void run () override;
        void kill () override { kill_.store (true); }

private:
        static int hotplugCallback (struct libusb_context * /* ctx */, struct libusb_device *dev, libusb_hotplug_event event, void *userData);
        libusb_hotplug_callback_handle hotplugCallbackHandle{};
        std::atomic_bool kill_;

        using UsbHandles = std::unordered_map<libusb_device const *, std::shared_ptr<UsbDevice>>;
        UsbHandles handles;
        std::mutex mutex; // Protects the `handles` collection.

        // TODO.
        /// Number of bytes received so far irrespective of the buffer size.
        // size_t receivedB () const { return allTransferedB; }
        // TimePoint globalStart;
        // TimePoint globalStop;
        // size_t allTransferedB{};

        UsbFactory usbFactory;
};

} // namespace logic