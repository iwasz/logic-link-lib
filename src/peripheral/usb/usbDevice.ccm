/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/error.hh"
#include "common/params.hh"
#include "common/stats.hh"
#include <algorithm>
#include <atomic>
#include <concepts>
#include <cstdint>
#include <cstdlib>
#include <libusb.h>
#include <vector>
export module logic.peripheral:usbDevice;
import logic.core;
import :input;
import :device;

namespace logic {

/**
 * Helper for sending USB control transfers in a more structured way.
 */
class UsbRequest {
public:
        UsbRequest &clazz (uint32_t c /* = GREATFET_CLASS_LA */) { return integer (c); }
        UsbRequest &verb (uint32_t v) { return integer (v); }
        UsbRequest &sampleRate (uint32_t v) { return integer (v); }
        UsbRequest &channels (uint8_t v) { return integer (v); }
        UsbRequest &size (uint32_t v) { return integer (v); }

        template <std::integral T> UsbRequest &integer (T u)
        {
                data_.resize (data_.size () + sizeof (u));
                uint8_t const *p = std::bit_cast<uint8_t *> (&u);
                std::copy (p, std::next (p, sizeof (u)), std::prev (data_.end (), sizeof (u)));
                return *this;
        }

        std::vector<uint8_t> const &data () const { return data_; }

private:
        std::vector<uint8_t> data_;
};

/**
 * Parameters speciffic to USB peripherals.
 */
export struct UsbTransmissionParams {

        /**
         * This one's for the UDB device.
         * TODO really, really document that, because I keep forgeting.
         */
        uint32_t usbBlock{};

        /**
         * Eaach bulk request initiated from the host to the device has exactly
         * this size, and we expect the device to respond with this amount of data.
         * This one's for the host only (doesn't get sent to the USB device).
         */
        size_t singleTransferLenB{}; //
        // uint32_t dmaBlock {};

        /**
         * Tells if the device should compress the data it is sending, and if the
         * acompanying host side code should decompress it.
         */
        bool decompress{};

        /**
         * Setting this to false will make the raw data to persist. Is a scenario
         * where we don't discard raw queue elements even feasible though?
         */
        bool discardRaw = true;
};

export struct UsbInterface {
        int claimInterface{};
        int interfaceNumber{};
        int alternateSetting{};
};

/**
 * Speciffic for **libusb**. Responsible for:
 * - Holds the internal representation (libusb_device_handle *)
 * - Can configure USb class / interface and app-logic stuff (using USB requests).
 */
export class UsbDevice : public AbstractDevice {
public:
        UsbDevice (EventQueue *eventQueue, libusb_device_handle *dev)
            : deviceHandle_{dev}, transfers (USB_BULK_TRANSFER_POOL_SIZE), eventQueue_{eventQueue}
        {
        }
        UsbDevice (UsbDevice const &) = delete;
        UsbDevice &operator= (UsbDevice const &) = delete;
        UsbDevice (UsbDevice &&) = delete;
        UsbDevice &operator= (UsbDevice &&) = delete;
        ~UsbDevice ();

        virtual void writeTransmissionParams (UsbTransmissionParams const &params);
        virtual UsbTransmissionParams readTransmissionParams () const = 0;

        /**
         * Starts the continuous, main bulk transfer. Inits the libusb transfer
         * structure, our internal data buffer, and makest this bulk transfer to
         * be resubmited everytime it finishes (hence continuous).
         */
        void start (IBackend *backend) override;
        void stop () override;
        void run () override;

        // Called by the controling input on disconnect or destroy.
        void resetDeviceHandle () { deviceHandle_ = nullptr; }

protected:
        libusb_device_handle *deviceHandle () { return deviceHandle_; };
        EventQueue *eventQueue () override { return eventQueue_; }

        /**
         * Basic USB bookeeping like opening thge device, claiming the interface
         * and so on. std::any used to accomodate for all possible busses, not only
         * USB.
         */
        void open (UsbInterface const &info);

        static void transferCallback (libusb_transfer *transfer);

        virtual void controlOut (std::vector<uint8_t> const &request) const;
        virtual void controlOut (UsbRequest const &request) const { controlOut (request.data ()); }
        virtual std::vector<uint8_t> controlIn (size_t len) const;
        virtual std::string getString (uint32_t clazz, uint32_t verb, size_t len) const;

        size_t singleTransferLenB () const { return transmissionParams_.singleTransferLenB; };

        UsbTransmissionParams &transmissionParams () { return transmissionParams_; }
        Queue<RawCompressedBlock> &queue () { return queue_; }
        IBackend *backend () { return backend_; }
        void setBackend (IBackend *b) { backend_ = b; }

private:
        mutable libusb_device_handle *deviceHandle_{};

        /// USB transfers are sent directly by this class (called by UsbAsyncInput).
        static constexpr size_t USB_BULK_TRANSFER_POOL_SIZE = 4;
        std::vector<libusb_transfer *> transfers;
        ;

        /*
         * We keep some defaults global (like compress == false) and some
         * speciffic to the device like singleTransferLenB below.
         */
        UsbTransmissionParams transmissionParams_ = {.singleTransferLenB = DEFAULT_USB_TRANSFER_SIZE_B};
        EventQueue *eventQueue_;

        /// Data received during the last transfer.
        Bytes singleTransfer;

        /// Current output, destination of the acquired data.
        Queue<RawCompressedBlock> queue_{};
        IBackend *backend_{};

        /// Used to stop re-issuing the transfer.
        std::atomic_bool acquisitionStopRequest;
        int64_t totalSizePerChan{};
};

} // namespace logic