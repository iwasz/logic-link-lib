/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <atomic>
export module logic.data:frontend;
import :types;
import :backend;

export namespace logic {

/**
 * Frontend implements a way of accessing the byte data that backend provides.
 * Frontend knows about the sample size.
 *
 * TODO I think there should be 1 frontend per group (for easier API design).
 * Some groups may be digital (1 bit interafces) and some analog (8bit, or more).
 * How am I supposed to invent an API general enough to facilitate all thsese
 * bit sizes?
 *
 * TODO OR ditch the frontend idea whatsoever. Mind that the range method does
 * completely nothing (at least for now).
 */
struct IFrontend {
        IFrontend () = default;
        IFrontend (IFrontend const &) = default;
        IFrontend &operator= (IFrontend const &) = default;
        IFrontend (IFrontend &&) noexcept = default;
        IFrontend &operator= (IFrontend &&) noexcept = default;
        virtual ~IFrontend () = default;

        // TODO rename channelLength
        /// Number of samples so far.
        virtual SampleNum size (size_t groupIdx) const = 0;

        virtual BlockArray::SubRange range (size_t groupIdx, SampleIdx offset, SampleNum length, size_t zoomOut, bool peek) const = 0;

        /// Says if there's new data since last called. Warning! Clears on read!
        virtual bool isNewData () const = 0;
};

/**
 * @brief
 */
class /*RandomAccess*/ DigitalFrontend : public IFrontend, public IBackendObserver {
public:
        explicit DigitalFrontend (IBackend *backend);
        DigitalFrontend (const DigitalFrontend &) = delete;
        DigitalFrontend &operator= (const DigitalFrontend &) = delete;
        DigitalFrontend (DigitalFrontend &&) noexcept = delete;
        DigitalFrontend &operator= (DigitalFrontend &&) noexcept = delete;
        ~DigitalFrontend ();

        SampleNum size (size_t groupIdx) const override { return backend->channelLength (groupIdx); }

        BlockArray::SubRange range (size_t groupIdx, SampleIdx offset, SampleNum length, size_t zoomOut, bool peek) const override;

        void onNewData () override { newData.store (true); };

        /// Warning! Clears on read!
        bool isNewData () const override;

private:
        IBackend *backend;
        SampleIdx cachedBegin{};
        SampleIdx cachedEnd{};
        mutable std::atomic_bool newData;
};

} // namespace logic