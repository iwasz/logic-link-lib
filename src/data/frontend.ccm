/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <atomic>
#include <climits>

export module logic.data:frontend;
import :types;
import :backend;
import logic.util;

export namespace logic {

/**
 * Frontend implements a way of accessing the byte data that backend provides.
 * Frontend knows about the sample size.
 *
 * TODO I think there should be 1 frontend per group (for easier API design).
 * Some groups may be digital (1 bit interafces) and some analog (8bit, or more).
 * How am I supposed to invent an API general enough to facilitate all thsese
 * bit sizes?
 */
struct IFrontend {
        IFrontend () = default;
        IFrontend (IFrontend const &) = default;
        IFrontend &operator= (IFrontend const &) = default;
        IFrontend (IFrontend &&) noexcept = default;
        IFrontend &operator= (IFrontend &&) noexcept = default;
        virtual ~IFrontend () = default;

        /// Number of samples so far.
        virtual SampleNum size (size_t groupIdx) const = 0;

        /**
         * All available new data, that was not read before. This is intrusive operation,
         * meaning that you get the data only once. It works like Java Iterator, but if there's
         * no new data, it will wait on a conditional_variable.
         */
        // virtual ChannelStreams next () = 0; // TODO this will go to a separate interface for Sequential access.

        /**
         * Returns all available data from a range of sample numbers.
         */
        // virtual ChannelStreams const &range (TimePoint const &begin, TimePoint const &end) = 0;

        // virtual ChannelStream const &group (size_t groupIdx, TimePoint const &begin, TimePoint const &end) = 0;
        virtual Stream const &group (size_t groupIdx, SampleIdx const &begin, SampleIdx const &end) = 0;

        // virtual Bytes const &channel (size_t groupIdx, size_t channelIdx, TimePoint const &begin, TimePoint const &end) = 0;
        // TODO following interface works only for the binary data
        virtual util::BitSpan<uint8_t const> channel (size_t groupIdx, size_t channelIdx, SampleIdx offset, SampleNum length) = 0;

        /// Says if there's new data since last called. Warning! Clears on read!
        virtual bool isNewData () = 0;
};

/**
 * @brief
 */
class /*RandomAccess*/ DigitalFrontend : public IFrontend, public IBackendObserver {
public:
        explicit DigitalFrontend (IBackend *backend);
        DigitalFrontend (const DigitalFrontend &) = delete;
        DigitalFrontend &operator= (const DigitalFrontend &) = delete;
        DigitalFrontend (DigitalFrontend &&) noexcept = delete;
        DigitalFrontend &operator= (DigitalFrontend &&) noexcept = delete;
        ~DigitalFrontend ();

        SampleNum size (size_t groupIdx) const override { return cache.at (groupIdx).channelLength () * CHAR_BIT; }
        Stream const &group (size_t groupIdx, SampleIdx const &begin, SampleIdx const &end) override;
        util::BitSpan<uint8_t const> channel (size_t groupIdx, size_t channelIdx, SampleIdx begin, SampleNum length) override;

        // ChannelStreams next () override { return {}; }
        // ChannelStreams const &range (TimePoint const &begin, TimePoint const &end) override { return current; }

        // ChannelStream const &group (size_t groupIdx, TimePoint const &begin, TimePoint const &end) override
        // {
        //         return range (begin, end).at (groupIdx);
        // }

        // Bytes const &channel (size_t groupIdx, size_t channelIdx, TimePoint const &begin, TimePoint const &end) override
        // {
        //         (void)backend;
        //         return group (groupIdx, begin, end).data.at (channelIdx);
        // }

        // std::span<uint8_t const> channel (size_t groupIdx, size_t channelIdx, SampleIdx const &begin, SampleIdx const &end)
        // override
        // {
        //         (void)backend;
        //         Bytes const &currentData = group (groupIdx, begin, end).data.at (channelIdx);
        //         auto offset = begin / CHAR_BIT;

        //         if (offset >= currentData.size ()) {
        //                 return {};
        //         }

        //         auto size = (end - begin) / CHAR_BIT;

        //         if (offset + size > currentData.size ()) {
        //                 size = currentData.size () - offset;
        //         }

        //         // std::println ("offset: {}, size: {}", offset, size);
        //         return {std::next (currentData.cbegin (), offset), size};
        // }

        void onNewData () override { newData.store (true); };

        /// Warning! Clears on read!
        bool isNewData () override;

private:
        IBackend *backend;
        Streams cache;
        SampleIdx cachedBegin{};
        SampleIdx cachedEnd{};
        std::atomic_bool newData;
};

/**
 * @brief
 *
 */
class SequentialAccessFrontend {};

} // namespace logic