/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <Tracy.hpp>
#include <vector>
export module logic.data:block;
import :types;

export namespace logic {

/**
 * Byte oriented data for a group of channels.
 */
class Block {
public:
        using Container = std::vector<Bytes>;

        Block () = default;

        /**
         * Construct from vector of bytes.
         */
        Block (uint8_t bitsPerSample, Container &&d, size_t zoomOut = 1) : bitsPerSample_{bitsPerSample}, data_{std::move (d)}, zoomOut_{zoomOut}
        {
        }

        Block (Block const &) = delete;
        Block &operator= (Block const &) = delete;
        Block (Block &&) = default;
        Block &operator= (Block &&) = default;
        ~Block () = default;

        void append (Container &&d);
        void append (Block &&d);
        void reserve (size_t channels, SampleNum bits);

        /// First valid sample index that can be referenced.
        SampleIdx firstSampleNo () const { return firstSampleNo_; }
        SampleIdx &firstSampleNo () { return firstSampleNo_; }

        /// Last valid sample index that can be referenced (do not confuse with "past-the-end" semantics).
        SampleIdx lastSampleNo () const
        {
                auto s = firstSampleNo_ + channelLength ();
                return (s > 0) ? (s - 1) : (0);
        }

        /// Number of channels in the block.
        size_t channelsNumber () const { return data_.size (); }

        /// Length of the block in samples. Assumes that all channels are the same length.
        SampleNum channelLength () const;
        size_t channelBytes () const;

        uint8_t bitsPerSample () const { return bitsPerSample_; }

        Bytes const &channel (size_t idx) const { return data_.at (idx); }
        Container const &data () const { return data_; }
        Container &&data () /* && */ { return std::move (data_); }

        size_t zoomOut () const { return zoomOut_; }

        // Truncates all the channels to 0.
        void clear ();

private:
        friend class BlockArray;          // Only for BlockArray::clipBytes which is not used anywhere, so....
        friend struct BlockArrayUtHelper; // Defined in UTs

        uint8_t bitsPerSample_{};
        SampleIdx firstSampleNo_{};
        // For now only Bytes are supported.
        Container data_; // Horizontal
        size_t zoomOut_ = 1;
};

SampleIdx firstSampleNo (Block const &b) { return b.firstSampleNo (); }
SampleIdx lastSampleNo (Block const &b) { return b.lastSampleNo (); }
size_t channelsNumber (Block const &b) { return b.channelsNumber (); }
SampleNum channelLength (Block const &b) { return b.channelLength (); }
uint8_t bitsPerSample (Block const &b) { return b.bitsPerSample (); }
size_t zoomOut (Block const &b) { return b.zoomOut (); }

} // namespace logic