/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <Tracy.hpp>
#include <vector>
export module logic.data:block;
import :types;

export namespace logic {

/**
 * Byte oriented data for a group of channels.
 */
class Block {
public:
        using Container = std::vector<Bytes>;

        Block () = default;

        /**
         * Construct from vector of bytes.
         */
        Block (SampleRate sampleRate, uint8_t bitsPerSample, Container &&d, size_t zoomOut = 1)
            : sampleRate_{sampleRate}, bitsPerSample_{bitsPerSample}, data_{std::move (d)}, zoomOut_{zoomOut}
        {
        }

        Block (Block const &) = delete;
        Block &operator= (Block const &) = delete;
        Block (Block &&) = default;
        Block &operator= (Block &&) = default;
        ~Block () = default;

        void append (Container &&d);
        void append (Block &&d);
        void reserve (size_t channels, size_t numberOfSampl);

        /// First valid sample index that can be referenced.
        SampleIdx firstSampleNo () const { return {firstSampleNo_, sampleRate_}; }

        void setFirstSampleNo (SampleIdx const &f)
        {
                srcheck (firstSampleNo (), f);
                firstSampleNo_ = f.get ();
        }

        /// Last valid sample index that can be referenced (do not confuse with "past-the-end" semantics).
        SampleIdx lastSampleNo () const
        {
                auto s = firstSampleNo_ + channelLength ().get ();
                return SampleIdx{(s > 0) ? (s - 1) : (0), sampleRate_};
        }

        /// Number of channels in the block.
        size_t channelsNumber () const { return data_.size (); }

        /// Length of the block in samples. Assumes that all channels are the same length.
        SampleNum channelLength () const;
        size_t channelBytes () const;

        uint8_t bitsPerSample () const { return bitsPerSample_; }
        SampleRate sampleRate () const { return sampleRate_; }

        Bytes const &channel (size_t idx) const { return data_.at (idx); }
        Container const &data () const { return data_; }

        size_t zoomOut () const { return zoomOut_; }

        // Truncates all the channels to 0.
        void clear ();

private:
        friend class BlockArray;          // Only for BlockArray::clipBytes which is not used anywhere, so....
        friend struct BlockArrayUtHelper; // Defined in UTs

        SampleRate sampleRate_;
        uint8_t bitsPerSample_{};
        ssize_t firstSampleNo_{};
        // For now only Bytes are supported.
        Container data_; // Horizontal
        size_t zoomOut_ = 1;
};

SampleIdx firstSampleNo (Block const &b) { return b.firstSampleNo (); }
SampleIdx lastSampleNo (Block const &b) { return b.lastSampleNo (); }
size_t channelsNumber (Block const &b) { return b.channelsNumber (); }
SampleNum channelLength (Block const &b) { return b.channelLength (); }
uint8_t bitsPerSample (Block const &b) { return b.bitsPerSample (); }
size_t zoomOut (Block const &b) { return b.zoomOut (); }

} // namespace logic