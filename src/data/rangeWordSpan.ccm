/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <algorithm>
#include <climits>
#include <cstdint>
#include <iterator>
export module logic.data:range.span.byte;

namespace logic {

/**
 * Iterator for BlockRangeWordSpan.
 */
template <std::unsigned_integral T, typename Container> class BlockRangeWordSpanIterator {
public:
        using BlockIterator = Container::const_iterator;
        using SubRange = std::ranges::subrange<BlockIterator>;                                // Block by block iteration.
        using ElementIterator = Container::value_type::Container::value_type::const_iterator; // T by T element iteration (usually byte by byte).
        using difference_type = std::ptrdiff_t;
        using value_type = T;

        BlockRangeWordSpanIterator () = default;
        BlockRangeWordSpanIterator (SubRange data, size_t blockRangeSize, size_t channelIndex, size_t byteOffset)
            : blockRange{data}, blockRangeSize{blockRangeSize}, currentBlockIterator{data.cbegin ()}, channelIndex{channelIndex}
        {
                advance (byteOffset);
        }

        T operator* () const;

        BlockRangeWordSpanIterator &operator++ ();
        BlockRangeWordSpanIterator operator++ (int);

        bool operator== (const BlockRangeWordSpanIterator &a) const;

        /// Advance by byteNumber bytes. Only forward. Public for UTs.
        void advance (size_t byteNumber);

private:
        static constexpr auto S = sizeof (T) * CHAR_BIT; // TODO more meaningful name

        /// Current block's channelIndex-th channel. The channel we want to iterate.
        auto const &channel () const { return currentBlockIterator->channel (channelIndex); }

        SubRange blockRange{};               // For example subrange<deque<Block>::const_iterator>;
        size_t blockRangeSize{};             // Copy of the size to avoid std::distance over a std::list
        BlockIterator currentBlockIterator;  // For example deque<Block>::const_iterator -> Block
        ElementIterator currentByteIterator; // For example std::vector<Bytes>::const_iterator

        size_t channelIndex{};
        // size_t currentBitOffset{};
        size_t currentByteOffset{};
        size_t currentBlockOffset{};
};

/****************************************************************************/

template <std::unsigned_integral T, typename Container> T BlockRangeWordSpanIterator<T, Container>::operator* () const
{
        return *currentByteIterator;
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container> void BlockRangeWordSpanIterator<T, Container>::advance (size_t bytesNumber)
{
        auto const byteOffset = bytesNumber;
        auto const channelLengthB = currentBlockIterator->channelLength () / S;

        currentByteOffset += byteOffset % channelLengthB;
        if (currentByteOffset >= channelLengthB) {
                currentByteOffset %= channelLengthB;
                ++currentBlockOffset;
        }

        currentBlockOffset += byteOffset / channelLengthB;

        currentBlockIterator = blockRange.cbegin ();

        if (currentBlockOffset >= blockRangeSize) {
                currentBlockOffset = blockRangeSize - 1;
                currentBlockIterator = blockRange.cend ();
                currentByteOffset = 0;
        }
        else {
                std::advance (currentBlockIterator, currentBlockOffset);
                currentByteIterator = channel ().cbegin ();
                std::advance (currentByteIterator, currentByteOffset);
        }
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container>
BlockRangeWordSpanIterator<T, Container> &BlockRangeWordSpanIterator<T, Container>::operator++ ()
{
        std::advance (currentByteIterator, 1);
        ++currentByteOffset;

        if (currentByteIterator == channel ().cend ()) {
                std::advance (currentBlockIterator, 1);
                ++currentBlockOffset;
                currentByteOffset = 0;

                if (currentBlockIterator != blockRange.cend ()) {
                        currentByteIterator = channel ().cbegin (); // TODO but whati  if block == cend? UB here.
                }
        }

        return *this;
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container>
BlockRangeWordSpanIterator<T, Container> BlockRangeWordSpanIterator<T, Container>::operator++ (int)
{
        auto tmp = *this;
        ++*this;
        return tmp;
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container>
bool BlockRangeWordSpanIterator<T, Container>::operator== (const BlockRangeWordSpanIterator &a) const
{
        return (currentBlockIterator == a.currentBlockIterator
                && currentBlockIterator == blockRange.cend ()) // If block iterator is at the end, there is no valid element iterator
                || (currentBlockIterator == a.currentBlockIterator && currentByteIterator == a.currentByteIterator
                    && channelIndex == a.channelIndex);
}

/**
 * Semantics like std::span, but works on a subrange of Blocks. Tested
 * for T == uint8_t only (for now).
 * TODO This thing (among with the acompanying iterator) is almost identical
 * to BlockRangeBitSpan. Reduce code duplication.
 */
export template <std::unsigned_integral T, typename Container> class BlockRangeWordSpan {
public:
        // Container: for example std::deque<Block>
        using SubRange = std::ranges::subrange<typename Container::const_iterator>;
        using iterator = BlockRangeWordSpanIterator<T, Container>;
        using const_iterator = BlockRangeWordSpanIterator<T const, Container>;
        using value_type = T;

        BlockRangeWordSpan () = default;
        BlockRangeWordSpan (SubRange data, size_t channelIndex, size_t byteOffset, size_t byteLength)
            : data{data},
              dataSize{size_t (std::ranges::distance (data))}, // TODO This is linear (instead of O(1)) if Container is a std::list
              channelIndex{channelIndex},
              offsetInBytes{byteOffset},
              sizeInBytes{trimSize (byteLength)}
        {
        }

        iterator begin () { return {data, dataSize, channelIndex, offsetInBytes}; }
        const_iterator begin () const { return {data, dataSize, channelIndex, offsetInBytes}; }
        const_iterator cbegin () const { return {data, dataSize, channelIndex, offsetInBytes}; }

        iterator end () { return {data, dataSize, channelIndex, offsetInBytes + sizeInBytes}; }
        const_iterator end () const { return {data, dataSize, channelIndex, offsetInBytes + sizeInBytes}; }
        const_iterator cend () const { return {data, dataSize, channelIndex, offsetInBytes + sizeInBytes}; }

        size_t size () const { return sizeInBytes; }
        bool empty () const { return sizeInBytes == 0; }

private:
        static constexpr auto BITS_PER_T = sizeof (T) * CHAR_BIT;
        size_t trimSize (size_t offset) const;

        SubRange data{};
        size_t dataSize{};
        size_t channelIndex{};
        size_t offsetInBytes{};
        size_t sizeInBytes{};
};

/****************************************************************************/

template <std::unsigned_integral T, typename Container> size_t BlockRangeWordSpan<T, Container>::trimSize (size_t offset) const
{
        if (data.empty ()) {
                return 0;
        }

        auto const maxLength = (data.front ().channelLength () / BITS_PER_T) * dataSize; // In S units
        return std::min<size_t> (maxLength - offsetInBytes, offset);
}

} // namespace logic