/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <algorithm>
#include <climits>
#include <iterator>
export module logic.data:range.span;

namespace logic {

/**
 * Iterator for BlockRangeBitSpan.
 */
template <std::unsigned_integral T, typename Container> class BlockRangeBitSpanIterator {
public:
        using BlockIterator = Container::const_iterator;
        using SubRange = std::ranges::subrange<BlockIterator>;                                // Block by block iteration.
        using ElementIterator = Container::value_type::Container::value_type::const_iterator; // T by T element iteration (usually byte by byte).
        using difference_type = std::ptrdiff_t;
        using value_type = bool;

        BlockRangeBitSpanIterator () = default;
        BlockRangeBitSpanIterator (SubRange data, size_t blockRangeSize, size_t channelIndex, size_t bitOffset)
            : blockRange{data}, blockRangeSize{blockRangeSize}, currentBlockIterator{data.cbegin ()}, channelIndex{channelIndex}
        {
                advance (bitOffset);
        }

        bool operator* () const;

        BlockRangeBitSpanIterator &operator++ ();
        BlockRangeBitSpanIterator operator++ (int);

        bool operator== (const BlockRangeBitSpanIterator &a) const;

        /// Advance by bitsNumber bits.  Only forward. Public for UTs.
        void advance (size_t bitsNumber);

private:
        static constexpr auto S = sizeof (T) * CHAR_BIT;

        /// Current block's channelIndex-th channel. The channel we want to iterate.
        auto const &channel () const { return currentBlockIterator->channel (channelIndex); }

        SubRange blockRange{};               // For example subrange<deque<Block>::const_iterator>;
        size_t blockRangeSize{};             // Copy of the size to avoid std::distance over a std::list
        BlockIterator currentBlockIterator;  // For example deque<Block>::const_iterator -> Block
        ElementIterator currentByteIterator; // For example std::vector<Bytes>::const_iterator

        size_t channelIndex{};
        size_t currentBitOffset{};
        size_t currentByteOffset{};
        size_t currentBlockOffset{};
};

// Move to BlockArray
// static_assert (std::bidirectional_iterator<RangeIterator<uint8_t, std::deque<Block>>>);

/****************************************************************************/

template <std::unsigned_integral T, typename Container> bool BlockRangeBitSpanIterator<T, Container>::operator* () const
{
        return (*currentByteIterator & T (1 << (S - 1 - currentBitOffset))) != 0;
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container> void BlockRangeBitSpanIterator<T, Container>::advance (size_t bitsNumber)
{
        currentBitOffset += bitsNumber % S;
        auto byteOffset = bitsNumber / S; // That much bytes

        if (currentBitOffset >= S) {
                currentBitOffset %= S;
                ++byteOffset;
        }

        auto const channelLengthB = currentBlockIterator->channelLength () / S;

        currentByteOffset += byteOffset % channelLengthB;
        if (currentByteOffset >= channelLengthB) {
                currentByteOffset %= channelLengthB;
                ++currentBlockOffset;
        }

        currentBlockOffset += byteOffset / channelLengthB;

        currentBlockIterator = blockRange.cbegin ();

        if (currentBlockOffset >= blockRangeSize) {
                currentBlockOffset = blockRangeSize - 1;
                currentBlockIterator = blockRange.cend ();
                currentBitOffset = 0;
                currentByteOffset = 0;
        }
        else {
                std::advance (currentBlockIterator, currentBlockOffset);
                currentByteIterator = channel ().cbegin ();
                std::advance (currentByteIterator, currentByteOffset);
        }
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container>
BlockRangeBitSpanIterator<T, Container> &BlockRangeBitSpanIterator<T, Container>::operator++ ()
{
        if (++currentBitOffset >= S) {
                currentBitOffset = 0;
                std::advance (currentByteIterator, 1);
                ++currentByteOffset;

                if (currentByteIterator == channel ().cend ()) {
                        std::advance (currentBlockIterator, 1);
                        ++currentBlockOffset;
                        currentByteOffset = 0;

                        if (currentBlockIterator != blockRange.cend ()) {
                                currentByteIterator = channel ().cbegin (); // TODO but whati  if block == cend? UB here.
                        }
                }
        }

        return *this;
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container>
BlockRangeBitSpanIterator<T, Container> BlockRangeBitSpanIterator<T, Container>::operator++ (int)
{
        auto tmp = *this;
        ++*this;
        return tmp;
}

/****************************************************************************/

template <std::unsigned_integral T, typename Container>
bool BlockRangeBitSpanIterator<T, Container>::operator== (const BlockRangeBitSpanIterator &a) const
{
        return (currentBlockIterator == a.currentBlockIterator
                && currentBlockIterator == blockRange.cend ()) // If block iterator is at the end, there is no valid element iterator
                || (currentBlockIterator == a.currentBlockIterator && currentByteIterator == a.currentByteIterator
                    && channelIndex == a.channelIndex && currentBitOffset == a.currentBitOffset);
}

/**
 * Semantics like std::span, but iteration happens bit by bit instead of
 * T element after T element. Bits are iterated over in the big endian manner
 * meaning from left to right. Works on ranges of Blocks returned from
 * a Backend.
 */
export template <std::unsigned_integral T, typename Container> class BlockRangeBitSpan {
public:
        // Container: for example std::deque<Block>
        using SubRange = std::ranges::subrange<typename Container::const_iterator>;
        using iterator = BlockRangeBitSpanIterator<T, Container>;
        using const_iterator = BlockRangeBitSpanIterator<T const, Container>;
        using value_type = bool;
        static constexpr bool SAMPLES = true;
        static constexpr bool DIGITAL = true;

        BlockRangeBitSpan () = default;
        BlockRangeBitSpan (SubRange data, size_t channelIndex, size_t bitOffset, size_t bitSize)
            : data{data},
              dataSize{size_t (std::ranges::distance (data))}, // TODO This is linear (instead of O(1)) if Container is a std::list
              channelIndex{channelIndex},
              offsetInBits{bitOffset},
              sizeInBits{trimSize (bitSize)}
        {
        }

        iterator begin () { return {data, dataSize, channelIndex, offsetInBits}; }
        const_iterator begin () const { return {data, dataSize, channelIndex, offsetInBits}; }
        const_iterator cbegin () const { return {data, dataSize, channelIndex, offsetInBits}; }

        iterator end () { return {data, dataSize, channelIndex, offsetInBits + sizeInBits}; }
        const_iterator end () const { return {data, dataSize, channelIndex, offsetInBits + sizeInBits}; }
        const_iterator cend () const { return {data, dataSize, channelIndex, offsetInBits + sizeInBits}; }

        /// Size in bits.
        size_t size () const { return sizeInBits; }
        bool empty () const { return sizeInBits == 0; }

private:
        static constexpr auto S = sizeof (T) * CHAR_BIT;
        size_t trimSize (size_t offset) const;

        SubRange data{};
        size_t dataSize{};
        size_t channelIndex{};
        size_t offsetInBits{};
        size_t sizeInBits{};
};

/****************************************************************************/

template <std::unsigned_integral T, typename Container> size_t BlockRangeBitSpan<T, Container>::trimSize (size_t offset) const
{
        if (data.empty ()) {
                return 0;
        }

        auto const maxLength = data.front ().channelLength () * dataSize; // In S units
        return std::min<size_t> (maxLength - offsetInBits, offset);
}

} // namespace logic