/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <Tracy.hpp>
#include <algorithm>
#include <climits>
#include <list>
#include <map>
#include <mutex>
#include <ranges>
#include <unordered_set>
#include <vector>
export module logic.data:backend;
import :types;

export namespace logic {
class BlockArray;
class Block;

template <typename Range>
concept block_range = std::ranges::range<Range> && std::convertible_to<std::remove_cvref_t<std::ranges::range_reference_t<Range>>, Block>;

/**
 * Byte oriented data for a group of channels.
 */
class Block {
public:
        using Container = std::vector<Bytes>;

        Block () = default;

        /**
         * Construct from vector of bytes.
         */
        Block (uint8_t bitsPerSample, Container &&d, size_t zoomOut = 1) : bitsPerSample_{bitsPerSample}, data_{std::move (d)}, zoomOut_{zoomOut}
        {
        }

        void append (Container &&d);
        void append (Block &&d);
        void reserve (size_t channels, SampleNum bits);

        /// First valid sample index that can be referenced.
        SampleIdx firstSampleNo () const { return firstSampleNo_; }
        SampleIdx &firstSampleNo () { return firstSampleNo_; }

        /// Last valid sample index that can be referenced (do not confuse with "past-the-end" semantics).
        SampleIdx lastSampleNo () const
        {
                auto s = firstSampleNo_ + channelLength ();
                return (s > 0) ? (s - 1) : (0);
        }

        /// Number of channels in the block.
        size_t channelsNumber () const { return data_.size (); }

        /// Length of the block in samples. Assumes that all channels are the same length.
        SampleNum channelLength () const;
        size_t bytesUsed () const;

        uint8_t bitsPerSample () const { return bitsPerSample_; }

        Bytes const &channel (size_t idx) const { return data_.at (idx); }
        Container const &data () const { return data_; }
        Container &&data () /* && */ { return std::move (data_); }

        size_t zoomOut () const { return zoomOut_; }

        // Truncates all the channels to 0.
        void clear ();

private:
        friend class BlockArray;          // Only for BlockArray::clipBytes which is not used anywhere, so....
        friend struct BlockArrayUtHelper; // Defined in UTs

        uint8_t bitsPerSample_{};
        SampleIdx firstSampleNo_{};
        // For now only Bytes are supported.
        Container data_; // Horizontal
        size_t zoomOut_ = 1;
};

SampleIdx firstSampleNo (Block const &b) { return b.firstSampleNo (); }
SampleIdx lastSampleNo (Block const &b) { return b.lastSampleNo (); }
size_t channelsNumber (Block const &b) { return b.channelsNumber (); }
SampleNum channelLength (Block const &b) { return b.channelLength (); }
uint8_t bitsPerSample (Block const &b) { return b.bitsPerSample (); }
size_t zoomOut (Block const &b) { return b.zoomOut (); }

template <block_range Range> SampleIdx firstSampleNo (Range const &r)
{
        return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->firstSampleNo ());
}

template <block_range Range> SampleIdx lastSampleNo (Range const &r) { return (std::ranges::empty (r)) ? (0) : (r.back ().lastSampleNo ()); }

template <block_range Range> size_t channelsNumber (Range const &r)
{
        return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->channelsNumber ());
}

template <block_range Range> SampleNum channelLength (Range const &r)
{
        // I assume all channels (except the last) have equal length.
        SampleNum size{};

        if (auto rsize = std::ranges::distance (r); rsize > 1) {
                size = std::ranges::begin (r)->channelLength () * (rsize - 1);
        }

        // This imposes some restricions.
        size += r.back ().channelLength ();

        // This is suboptimal:
        // return std::ranges::fold_left (r | std::views::transform ([] (auto const &block) { return block.channelLength (); }), 0,
        //                                std::plus<SampleNum> ());

        return size;
}

template <block_range Range> uint8_t bitsPerSample (Range const &r)
{
        return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->bitsPerSample ());
}

template <block_range Range> size_t zoomOut (Range const &r) { return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->zoomOut ()); }

/**
 * Like block, but should be regarded as a continuous and presumable longer
 * buffer than the single bloc. Generally multiple blocks will get joined
 * together to form a stream, even though the C++ data type is the same.
 */
using Stream = Block;

/**
 * Multiple blocks one after another.
 * TODO more constraints: constraint the block size (in the append etc.)
 */
class BlockArray {
public:
        static constexpr size_t DEFAULT_ZOOM_OUT_PER_LEVEL = 16; // Every next level is zoomed-out by this value.

        /*
         * TODO The container first was a std::deque, but deque uses 2 vectors inside and
         * invalidates (it may) it's ityerators on push_back and my app crashed (I store
         * these iterators and pass them around). I temporarily switched to pre-allocated
         * std::vector and all was fine but then as a final solution I opted for std::list.
         * And it started to crash again (search Obsidian for `deque`). Albeit I believe,
         * this time the culprit are not invalidated iters, EVEN THOUGH switching back to
         * pre-allocated vector seems to make the problem go away.
         * After introducing levels, the `reserve` call doesn't get called when BlockArray
         * gets copied / moved, and thus I moved yet another time do std::list.
         */
        // using Container = std::vector<Block>;
        using Container = std::list<Block>;
        using SubRange = std::ranges::subrange<Container::const_iterator>;

        /// Note that cb is passed by value. Move.
        void append (uint8_t bitsPerSample, std::vector<Bytes> &&channels);
        void clear ();

        BlockArray (size_t maxZoomOutLevels = 1, size_t zoomOutPerLevel = DEFAULT_ZOOM_OUT_PER_LEVEL)
            : levels (std::max (maxZoomOutLevels, 1uz)), zoomOutPerLevel{zoomOutPerLevel}
        {
                for (size_t curZoomOut = 1; auto &lev : levels) {
                        lev.zoomOut = curZoomOut;
                        curZoomOut *= zoomOutPerLevel;
                }
        }

        /**
         * Returns block range that includes sample numbers passed (inclusive).
         */
        SubRange range (SampleIdx begin, SampleIdx end, SampleNum maxDiscernibleSamples = -1) const;

        /**
         * Returns a Stream cut precisely down to the byte.
         * @deprecated Use more fine grained methods. To be removed.
         */
        Stream clipBytes (ByteIdx begin, ByteIdx end);

        size_t channelsNumber () const { return (levels[0].data_.empty ()) ? (0) : (levels[0].data_.front ().channelsNumber ()); }
        SampleNum channelLength () const { return channelLength_; }

private:
        friend struct BlockArrayUtHelper; // Defined in UTs

        StreamType type_{};
        SampleRate sampleRate_{};
        // SampleIdx currentSampleNo{};
        using BlockIndex = std::map<SampleIdx, Container::const_iterator>;

        struct ZoomOutLevel {
                // ZoomOutLevel () { data_.reserve (2000000); }
                Container data_;   // Grows horizontally.
                BlockIndex index_; // Like DB index SampleIndex -> block.
                size_t zoomOut = 1;
                Container::const_iterator zoomedEnd = data_.cbegin ();
        };

        std::vector<ZoomOutLevel> levels;
        size_t zoomOutPerLevel;

        SampleNum channelLength_{};
};

// Multiple BlockArray-s, each represeinging one channel-group
using BlockArrays = std::vector<BlockArray>;
using Streams = std::vector<Stream>;

struct IBackendObserver {
        IBackendObserver () = default;
        IBackendObserver (IBackendObserver const &) = default;
        IBackendObserver &operator= (IBackendObserver const &) = default;
        IBackendObserver (IBackendObserver &&) noexcept = default;
        IBackendObserver &operator= (IBackendObserver &&) noexcept = default;
        virtual ~IBackendObserver () = default;

        virtual void onNewData () = 0;
};

/**
 * A database for string (sample) data in uniform format. It let's you retrieve
 * apropriate byte blocks of data, but doesn't / shouldn't have access per sample.
 * To access individual samples (whatever their size might be) use a frontend.
 */
struct IBackend {
        using SubRange = BlockArray::SubRange;

        IBackend () = default;
        IBackend (IBackend const &) = default;
        IBackend &operator= (IBackend const &) = default;
        IBackend (IBackend &&) noexcept = default;
        IBackend &operator= (IBackend &&) noexcept = default;
        virtual ~IBackend () = default;

        // using SubRange = ChannelBlockStream::SubRange;

        /// Adds s[0] to stream[0], s[1] to stream[1] etc
        virtual void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) = 0;
        virtual void clear () = 0;

        /**
         * Returns a stream made of concatenated blocks containing the
         * begin and end samples. Returned stream may start long before
         * the `begin` sample and finish after the `end` sample, so you
         * have to trim it yourself (use std::span / BitSpan).
         */
        virtual SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end, SampleNum maxDiscernibleSamples = -1) const = 0;
        virtual size_t groupsNo () const = 0;

        virtual size_t channelsNumber (size_t groupIdx) const = 0;
        virtual SampleNum channelLength (size_t groupIdx) const = 0;

        virtual void addObserver (IBackendObserver *observer) = 0;
        virtual void removeObserver (IBackendObserver *observer) = 0;
};

/**
 *
 */
class Backend : public IBackend {
public:
        Backend () : groups{BlockArray{10, 2}} {} // TODO configurable number of groups.
        Backend (size_t maxZoomOutLevels, size_t zoomOutPerLevel) : groups{BlockArray{maxZoomOutLevels, zoomOutPerLevel}} {}

        void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) override;
        void clear () override;

        SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end, SampleNum maxDiscernibleSamples = -1) const override;

        void configureGroup (size_t groupIdx, SampleRate sampleRate); // TODO not used. Remove the CTOr and use this somewhere.
        size_t groupsNo () const override { return groups.size (); }

        size_t channelsNumber (size_t groupIdx) const override { return groups.at (groupIdx).channelsNumber (); }
        SampleNum channelLength (size_t groupIdx) const override;

        void addObserver (IBackendObserver *observer) override { observers.insert (observer); }
        void removeObserver (IBackendObserver *observer) override { observers.erase (observer); }

private:
        void notifyObservers ();

        BlockArrays groups;
        mutable TracyLockable (std::mutex, mutex);
        std::unordered_set<IBackendObserver *> observers;
};

} // namespace logic