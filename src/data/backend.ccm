/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <Tracy.hpp>
#include <algorithm>
#include <list>
#include <map>
#include <memory>
#include <mutex>
#include <ranges>
#include <unordered_set>
#include <vector>
export module logic.data:backend;
import :types;

export namespace logic {
class BlockArray;
class Block;

template <typename Range>
concept block_range = std::ranges::range<Range> && std::convertible_to<std::remove_cvref_t<std::ranges::range_reference_t<Range>>, Block>;

/**
 *
 */
struct IDownSampler {
        IDownSampler () = default;
        IDownSampler (IDownSampler const &) = default;
        IDownSampler &operator= (IDownSampler const &) = default;
        IDownSampler (IDownSampler &&) noexcept = default;
        IDownSampler &operator= (IDownSampler &&) noexcept = default;
        virtual ~IDownSampler () = default;

        virtual Bytes operator() (Bytes const &in, size_t zoomOut) const = 0;
};

/**
 * Class preservig the "even bit" state.
 */
class DigitalDownSampler : public IDownSampler {
public:
        Bytes operator() (Bytes const &block, size_t zoomOut) const override;

private:
        mutable uint8_t state{};
};

/****************************************************************************/

/**
 * Byte oriented data for a group of channels.
 */
class Block {
public:
        using Container = std::vector<Bytes>;

        Block () = default;

        /**
         * Construct from vector of bytes.
         */
        Block (uint8_t bitsPerSample, Container &&d, size_t zoomOut = 1) : bitsPerSample_{bitsPerSample}, data_{std::move (d)}, zoomOut_{zoomOut}
        {
        }

        void append (Container &&d);
        void append (Block &&d);
        void reserve (size_t channels, SampleNum bits);

        /// First valid sample index that can be referenced.
        SampleIdx firstSampleNo () const { return firstSampleNo_; }
        SampleIdx &firstSampleNo () { return firstSampleNo_; }

        /// Last valid sample index that can be referenced (do not confuse with "past-the-end" semantics).
        SampleIdx lastSampleNo () const
        {
                auto s = firstSampleNo_ + channelLength ();
                return (s > 0) ? (s - 1) : (0);
        }

        /// Number of channels in the block.
        size_t channelsNumber () const { return data_.size (); }

        /// Length of the block in samples. Assumes that all channels are the same length.
        SampleNum channelLength () const;
        size_t channelBytes () const;

        uint8_t bitsPerSample () const { return bitsPerSample_; }

        Bytes const &channel (size_t idx) const { return data_.at (idx); }
        Container const &data () const { return data_; }
        Container &&data () /* && */ { return std::move (data_); }

        size_t zoomOut () const { return zoomOut_; }

        // Truncates all the channels to 0.
        void clear ();

private:
        friend class BlockArray;          // Only for BlockArray::clipBytes which is not used anywhere, so....
        friend struct BlockArrayUtHelper; // Defined in UTs

        uint8_t bitsPerSample_{};
        SampleIdx firstSampleNo_{};
        // For now only Bytes are supported.
        Container data_; // Horizontal
        size_t zoomOut_ = 1;
};

SampleIdx firstSampleNo (Block const &b) { return b.firstSampleNo (); }
SampleIdx lastSampleNo (Block const &b) { return b.lastSampleNo (); }
size_t channelsNumber (Block const &b) { return b.channelsNumber (); }
SampleNum channelLength (Block const &b) { return b.channelLength (); }
uint8_t bitsPerSample (Block const &b) { return b.bitsPerSample (); }
size_t zoomOut (Block const &b) { return b.zoomOut (); }

template <block_range Range> SampleIdx firstSampleNo (Range const &r)
{
        return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->firstSampleNo ());
}

template <block_range Range> SampleIdx lastSampleNo (Range const &r) { return (std::ranges::empty (r)) ? (0) : (r.back ().lastSampleNo ()); }

template <block_range Range> size_t channelsNumber (Range const &r)
{
        return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->channelsNumber ());
}

template <block_range Range> SampleNum channelLength (Range const &r)
{
        // I assume all channels (except the last) have equal length.
        SampleNum size{};

        if (auto rsize = std::ranges::distance (r); rsize > 1) {
                size = std::ranges::begin (r)->channelLength () * (rsize - 1);
        }

        // This imposes some restricions.
        size += r.back ().channelLength ();

        // This is suboptimal:
        // return std::ranges::fold_left (r | std::views::transform ([] (auto const &block) { return block.channelLength (); }), 0,
        //                                std::plus<SampleNum> ());

        return size;
}

template <block_range Range> uint8_t bitsPerSample (Range const &r)
{
        return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->bitsPerSample ());
}

template <block_range Range> size_t zoomOut (Range const &r) { return (std::ranges::empty (r)) ? (0) : (std::ranges::begin (r)->zoomOut ()); }

/**
 * Like block, but should be regarded as a continuous and presumable longer
 * buffer than the single bloc. Generally multiple blocks will get joined
 * together to form a stream, even though the C++ data type is the same.
 */
using Stream = Block;

/**
 * Multiple blocks one after another.
 * TODO more constraints: constraint the block size (in the append etc.)
 */
class BlockArray {
public:
        /*
         * TODO The container first was a std::deque, but deque uses 2 vectors inside and
         * invalidates (it may) it's iterators on push_back and my app crashed (I store
         * these iterators and pass them around). I temporarily switched to pre-allocated
         * std::vector and all was fine but then as a final solution I opted for std::list.
         * And it started to crash again (search Obsidian for `deque`). Albeit I believe,
         * this time the culprit are not invalidated iters, EVEN THOUGH switching back to
         * pre-allocated vector seems to make the problem go away.
         * After introducing levels, the `reserve` call doesn't get called when BlockArray
         * gets copied / moved, and thus I moved yet another time do std::list.
         */
        // using Container = std::vector<Block>;
        using Container = std::list<Block>;
        using SubRange = std::ranges::subrange<Container::const_iterator>;

        BlockArray (size_t channelsNumber = 1, size_t maxZoomOutLevels = 1, size_t zoomOutPerLevel = 1);
        void append (uint8_t bitsPerSample, std::vector<Bytes> &&channels);
        void clear ();

        /**
         * Returns block range that includes sample numbers passed (inclusive).
         */
        SubRange range (SampleIdx begin, SampleIdx end, size_t zoomOut = 1, bool peek = false) const;

        size_t channelsNumber () const { return (levels[0].data_.empty ()) ? (0) : (levels[0].data_.front ().channelsNumber ()); }
        SampleNum channelLength () const { return channelLength_; }

        size_t blockSizeB () const { return blockSizeB_; } /// Returns the block size. Block size is the number of bytes `append` accepts.
        void setBlockSizeB (size_t v) { blockSizeB_ = v; } /// Sets the block size.

        size_t blockSizeMultiplier () const { return blockSizeMultiplier_; }
        void setBlockSizeMultiplier (size_t v) { blockSizeMultiplier_ = v; }

private:
        friend struct BlockArrayUtHelper; // Defined in UTs
        using DownSamplers = std::vector<std::unique_ptr<IDownSampler>>;
        Block downsample (Block const &block, size_t zoomOut, DownSamplers const &downSamplers) const;

        // StreamType type_{};
        // SampleRate sampleRate_{};

        /// Block that we append to to reach blockSizeB_ * blockSizeMultiplier_ bytes.
        Block pendingBlock;

        using BlockIndex = std::map<SampleIdx, Container::const_iterator>;

        struct ZoomOutLevel {
                // ZoomOutLevel () { data_.reserve (2000000); }
                Container data_;   // Grows horizontally.
                BlockIndex index_; // Like DB index SampleIndex -> block.
                size_t zoomOut = 1;
                Container::const_iterator zoomedEnd = data_.cbegin ();
                std::vector<std::unique_ptr<IDownSampler>> downSamplers;
        };

        std::vector<ZoomOutLevel> levels;
        size_t zoomOutPerLevel;

        SampleNum channelLength_{};
        size_t blockSizeB_ = 0;
        size_t blockSizeMultiplier_ = 1;
};

// Multiple BlockArray-s, each represeinging one channel-group
using BlockArrays = std::vector<BlockArray>;
using Streams = std::vector<Stream>;

struct IBackendObserver {
        IBackendObserver () = default;
        IBackendObserver (IBackendObserver const &) = default;
        IBackendObserver &operator= (IBackendObserver const &) = default;
        IBackendObserver (IBackendObserver &&) noexcept = default;
        IBackendObserver &operator= (IBackendObserver &&) noexcept = default;
        virtual ~IBackendObserver () = default;

        virtual void onNewData () = 0;
};

/**
 * A database for string (sample) data in uniform format. It let's you retrieve
 * apropriate byte blocks of data, but doesn't / shouldn't have access per sample.
 * To access individual samples (whatever their size might be) use a frontend.
 */
struct IBackend {
        using SubRange = BlockArray::SubRange;

        IBackend () = default;
        IBackend (IBackend const &) = default;
        IBackend &operator= (IBackend const &) = default;
        IBackend (IBackend &&) noexcept = default;
        IBackend &operator= (IBackend &&) noexcept = default;
        virtual ~IBackend () = default;

        /// Adds s[0] to stream[0], s[1] to stream[1] etc
        virtual void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) = 0;
        virtual void clear () = 0;

        /**
         * Returns a stream made of concatenated blocks containing the
         * begin and end samples. Returned stream may start long before
         * the `begin` sample and finish after the `end` sample, so you
         * have to trim it yourself (use std::span / BitSpan).
         */
        virtual SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end, size_t zoomOut = 1, bool peek = false) const = 0;

        struct Config { // TODO change name to Group to reflect the qt counterpart
                size_t channelsNumber{};
                size_t maxZoomOutLevels = 1;
                size_t zoomOutPerLevel = 1;
                size_t blockSizeB = 0;
                size_t blockSizeMultiplier = 1;
        };

        /// Returns the added group index.
        virtual size_t addGroup (Config const &config) = 0;
        virtual size_t groupsNumber () const = 0;

        virtual size_t channelsNumber (size_t groupIdx) const = 0;
        virtual SampleNum channelLength (size_t groupIdx) const = 0;

        virtual void addObserver (IBackendObserver *observer) = 0;
        virtual void removeObserver (IBackendObserver *observer) = 0;
};

/**
 *
 */
class Backend : public IBackend {
public:
        void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) override;
        void clear () override;
        SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end, size_t zoomOut = 1, bool peek = false) const override;

        size_t addGroup (Config const &config) override;
        size_t groupsNumber () const override { return groups_.size (); }

        size_t channelsNumber (size_t groupIdx) const override { return groups_.at (groupIdx).channelsNumber (); }
        SampleNum channelLength (size_t groupIdx) const override;

        void addObserver (IBackendObserver *observer) override { observers.insert (observer); }
        void removeObserver (IBackendObserver *observer) override { observers.erase (observer); }

private:
        void notifyObservers ();

        BlockArrays groups_;
        mutable TracyLockable (std::mutex, mutex);
        std::unordered_set<IBackendObserver *> observers;
};

} // namespace logic