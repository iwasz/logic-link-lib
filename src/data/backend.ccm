/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <Tracy.hpp>
#include <mutex>
#include <unordered_set>
#include <vector>
export module logic.data:backend;
import :block;
import :types;
import :blockArray;

export namespace logic {

struct IBackendObserver {
        IBackendObserver () = default;
        IBackendObserver (IBackendObserver const &) = default;
        IBackendObserver &operator= (IBackendObserver const &) = default;
        IBackendObserver (IBackendObserver &&) noexcept = default;
        IBackendObserver &operator= (IBackendObserver &&) noexcept = default;
        virtual ~IBackendObserver () = default;

        virtual void onNewData () = 0;
};

/**
 * A database for string (sample) data in uniform format. It let's you retrieve
 * apropriate byte blocks of data, but doesn't / shouldn't have access per sample.
 * To access individual samples (whatever their size might be) use a frontend.
 */
struct IBackend {
        using SubRange = BlockArray::SubRange;

        IBackend () = default;
        IBackend (IBackend const &) = default;
        IBackend &operator= (IBackend const &) = default;
        IBackend (IBackend &&) noexcept = default;
        IBackend &operator= (IBackend &&) noexcept = default;
        virtual ~IBackend () = default;

        /// Adds s[0] to stream[0], s[1] to stream[1] etc
        virtual void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) = 0;
        virtual void clear () = 0;

        /**
         * Returns a stream made of concatenated blocks containing the
         * begin and end samples (including both). Returned stream may
         * start long before the `begin` sample and finish after the `end`
         * sample, so you have to trim it yourself (use std::span / BitSpan).
         */
        virtual SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end, size_t zoomOut = 1, bool peek = false) const = 0;
        virtual SubRange range (size_t groupIdx, SampleIdx begin, SampleNum len, size_t zoomOut = 1, bool peek = false) const = 0;

        struct Group {
                size_t channelsNumber{};
                SampleRate sampleRate = 1_Sps;
                size_t maxZoomOutLevels = 1;
                size_t zoomOutPerLevel = 1;
                size_t blockSizeB = 16; // For UT
                size_t blockSizeMultiplier = 1;
        };

        /// Returns the added group index.
        virtual size_t addGroup (Group const &config) = 0;
        virtual size_t groupsNumber () const = 0;

        virtual size_t channelsNumber (size_t groupIdx) const = 0;

        /**
         * Channel length in the `smallest sample` unit i.e. most fine grained samples
         * this backend holds. Assuming all groups start and stop at the sasme time.
         * Assume a backend has 2 groups: digital at 1 Msps and analog at 1 ksps and
         * the device acquired data for 1s. This method will return SampleNum {1000'000, 1000'000}
         */
        virtual SampleNum channelLength () const = 0;
        virtual SampleNum channelLength (size_t groupIdx) const = 0;

        virtual SampleRate sampleRate () const = 0; /// Max from all the groups.
        virtual SampleRate sampleRate (size_t groupIdx) const = 0;

        virtual void addObserver (IBackendObserver *observer) = 0;
        virtual void removeObserver (IBackendObserver *observer) = 0;
};

/**
 *
 */
class Backend : public IBackend {
public:
        void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) override;
        void clear () override;

        SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end, size_t zoomOut = 1, bool peek = false) const override;
        SubRange range (size_t groupIdx, SampleIdx begin, SampleNum len, size_t zoomOut = 1, bool peek = false) const override;

        size_t addGroup (Group const &config) override;
        size_t groupsNumber () const override { return groups_.size (); }

        size_t channelsNumber (size_t groupIdx) const override { return groups_.at (groupIdx).channelsNumber (); }

        SampleNum channelLength () const override { return channelLength (fastestGroup_); }
        SampleNum channelLength (size_t groupIdx) const override;

        SampleRate sampleRate () const override { return sampleRate (fastestGroup_); }
        SampleRate sampleRate (size_t groupIdx) const override { return groups_.at (groupIdx).sampleRate (); }

        void addObserver (IBackendObserver *observer) override { observers.insert (observer); }
        void removeObserver (IBackendObserver *observer) override { observers.erase (observer); }

private:
        void notifyObservers ();

        BlockArrays groups_;
        mutable TracyLockable (std::mutex, mutex);
        std::unordered_set<IBackendObserver *> observers;
        size_t fastestGroup_{};
};

} // namespace logic