/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <Tracy.hpp>
#include <algorithm>
#include <climits>
#include <list>
#include <map>
#include <mutex>
#include <ranges>
#include <unordered_set>
#include <vector>
export module logic.data:backend;
import :types;

export namespace logic {
class BlockArray;

/**
 * Byte oriented data for a group of channels.
 */
class Block {
public:
        using Container = std::vector<Bytes>;

        Block () = default;
        Block (uint8_t bitsPerSample, size_t channels, size_t numberOfSamples);

        template <typename Range> explicit Block (Range const &range);

        Block (uint8_t bitsPerSample, /* SampleIdx firstSampleNo, */ Container &&d)
            : bitsPerSample_{bitsPerSample}, /* firstSampleNo_{firstSampleNo}, */ data_{std::move (d)}
        {
        }

        /// First valid sample index that can be referenced.
        SampleIdx firstSampleNo () const { return firstSampleNo_; }
        SampleIdx &firstSampleNo () { return firstSampleNo_; }

        /// Last valid sample index that can be referenced (do not confuse with "past-the-end" semantics).
        SampleIdx lastSampleNo () const
        {
                auto s = firstSampleNo_ + channelLength ();
                return (s > 0) ? (s - 1) : (0);
        }

        /// Number of channels in the block.
        size_t channelsNumber () const { return data_.size (); }

        /// Length of the block in samples. Assumes that all channels are the same length.
        SampleNum channelLength () const;

        uint8_t bitsPerSample () const { return bitsPerSample_; }

        Bytes const &channel (size_t idx) const { return data_.at (idx); }
        Container const &data () const { return data_; }

        // Truncates all the channels to 0.
        void clear ();

        // Only for BlockArray::clipBytes which is not used anywhere, so....
        friend class BlockArray;

private:
        uint8_t bitsPerSample_{};
        SampleIdx firstSampleNo_{};
        // For now only Bytes are supported.
        Container data_; // Horizontal
};

/*--------------------------------------------------------------------------*/

template <typename Range> Block::Block (Range const &range)
{
        if (range.empty ()) {
                return;
        }

        size_t byteSizeOfRange{};

        for (auto const &block : range) {
                // TODO works only (and tested only) for bitsPerSample == 1 or 8.
                byteSizeOfRange += block.channelLength () / (CHAR_BIT / block.bitsPerSample ());
        }

        Block const &front = range.front ();
        firstSampleNo_ = front.firstSampleNo ();
        bitsPerSample_ = front.bitsPerSample ();

        data_.resize (front.channelsNumber ());

        int chNo{};
        for (auto &ch : data_) {
                ch.reserve (byteSizeOfRange);

                for (auto const &sourceBlock : range) {
                        std::ranges::copy (sourceBlock.data_.at (chNo), std::back_inserter (ch));
                }

                ++chNo;
        }
}

/**
 * Like block, but should be regarded as a continuous and presumable longer
 * buffer than the single bloc. Generally multiple blocks will get joined
 * together to form a stream, even though the C++ data type is the same.
 */
using Stream = Block;

/**
 * Multiple blocks one after another.
 */
class BlockArray {
public:
        using Container = std::list<Block>;
        using SubRange = std::ranges::subrange<Container::const_iterator>;
        void append (uint8_t bitsPerSample, std::vector<Bytes> &&cb);
        void clear ();

        /**
         * Returns block range that includes sample numbers passed (inclusive).
         */
        SubRange range (SampleIdx begin, SampleIdx end) const;

        /**
         * Returns a Stream cut precisely down to the byte.
         */
        Stream clipBytes (ByteIdx begin, ByteIdx end);

        Container const &data () const { return data_; }

        // TODO Make it agnostic? Move to a frontend?
        StreamType type () const { return type_; }
        void setType (StreamType type) { type_ = type; }

        // TODO Make it agnostic? Move to a frontend?
        SampleRate sampleRate () const { return sampleRate_; }
        void setSampleRate (SampleRate sr) { sampleRate_ = sr; }

        size_t channelsNumber () const { return (data_.empty ()) ? (0) : (data_.front ().channelsNumber ()); }
        SampleNum channelLength () const;

private:
        StreamType type_{};
        SampleRate sampleRate_{};
        SampleIdx currentSampleNo{};
        Container data_; // Grows horizontally.
        using BlockIndex = std::map<SampleIdx, Container::const_iterator>;
        BlockIndex index_;          // Like DB index SampleIndex -> block.
        SampleNum channelLength_{}; // Assuming all channels have equal length.
};

// Multiple BlockArray-s, each represeinging one channel-group
using BlockArrays = std::vector<BlockArray>;
using Streams = std::vector<Stream>;

struct IBackendObserver {
        IBackendObserver () = default;
        IBackendObserver (IBackendObserver const &) = default;
        IBackendObserver &operator= (IBackendObserver const &) = default;
        IBackendObserver (IBackendObserver &&) noexcept = default;
        IBackendObserver &operator= (IBackendObserver &&) noexcept = default;
        virtual ~IBackendObserver () = default;

        virtual void onNewData () = 0;
};

/**
 * A database for string (sample) data in uniform format. It let's you retrieve
 * apropriate byte blocks of data, but doesn't / shouldn't have access per sample.
 * To access individual samples (whatever their size might be) use a frontend.
 */
struct IBackend {
        using SubRange = BlockArray::SubRange;

        IBackend () = default;
        IBackend (IBackend const &) = default;
        IBackend &operator= (IBackend const &) = default;
        IBackend (IBackend &&) noexcept = default;
        IBackend &operator= (IBackend &&) noexcept = default;
        virtual ~IBackend () = default;

        // using SubRange = ChannelBlockStream::SubRange;

        /// Adds s[0] to stream[0], s[1] to stream[1] etc
        virtual void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) = 0;
        virtual void clear () = 0;

        /**
         * Returns a stream made of concatenated blocks containing the
         * begin and end samples. Returned stream may start long before
         * the `begin` sample and finish after the `end` sample, so you
         * have to trim it yourself (use std::span / BitSpan).
         */
        virtual SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end) const = 0;
        virtual size_t groupsNo () const = 0;

        virtual size_t channelsNumber (size_t groupIdx) const = 0;
        virtual SampleNum channelLength (size_t groupIdx) const = 0;

        virtual void addObserver (IBackendObserver *observer) = 0;
        virtual void removeObserver (IBackendObserver *observer) = 0;
};

/**
 *
 */
class Backend : public IBackend {
public:
        Backend () : groups (1) {} // TODO configurable number of groups.

        void append (size_t groupIdx, uint8_t bitsPerSample, std::vector<Bytes> &&s) override;
        void clear () override;

        SubRange range (size_t groupIdx, SampleIdx begin, SampleIdx end) const override;

        void configureGroup (size_t groupIdx, SampleRate sampleRate); // TODO not used. Remove the CTOr and use this somewhere.
        size_t groupsNo () const override { return groups.size (); }

        size_t channelsNumber (size_t groupIdx) const override { return groups.at (groupIdx).channelsNumber (); }
        SampleNum channelLength (size_t groupIdx) const override;

        void addObserver (IBackendObserver *observer) override { observers.insert (observer); }
        void removeObserver (IBackendObserver *observer) override { observers.erase (observer); }

private:
        void notifyObservers ();

        BlockArrays groups;
        mutable TracyLockable (std::mutex, mutex);
        std::unordered_set<IBackendObserver *> observers;
};

} // namespace logic