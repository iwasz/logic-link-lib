/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <chrono>
#include <condition_variable>
#include <deque>
#include <mutex>
#include <variant>
#include <vector>
export module logic.data:types;

export namespace logic {

template <typename T>
concept byte_collection = requires {
        typename T::value_type;
        requires sizeof (typename T::value_type) == 1;
} && std::integral<std::remove_cv_t<typename T::value_type>>;

/// Simply check a boolean variable.
template <typename T>
concept sample_collection = requires (T t) {
        T::SAMPLES;
        requires T::SAMPLES;
};

template <typename T>
concept digital_sample_collection = sample_collection<T> && requires (T t) {
        T::DIGITAL;
        requires T::DIGITAL;
};

/****************************************************************************/

using TimePoint = std::chrono::high_resolution_clock::time_point;

using Bytes = std::vector<uint8_t>;
using Words = std::vector<uint32_t>;
using Numbers = std::vector<float>;
using Buffer = std::variant<Bytes, Words, Numbers>;

enum class StreamType : uint8_t { digital, analog };

using SampleIdx = int64_t;
using SampleNum = int64_t;
using ByteIdx = int64_t;
using ByteNum = int64_t;

SampleIdx relativeBegin (SampleIdx index, SampleIdx rangeBegin, size_t zoomOut) { return (index - rangeBegin) / zoomOut; }
SampleIdx relativeEnd (SampleIdx index, SampleIdx rangeBegin, size_t zoomOut)
{
        return ((index - rangeBegin) / zoomOut) - 1 + (((index - rangeBegin) % zoomOut == zoomOut - 1) ? (1) : (0));
}

/**
 * The data as received from the device. Possibly compressed with LZ4.
 */
struct RawCompressedBlock {
        double bps{};        /// Debug data indicating bits per second. Not sampling rate.
        size_t overrunsNo{}; /// Number of problems that occured during the reception.
        Bytes buffer;        /// Binary data.

        void clear () { buffer.clear (); }
};

/**
 * The same data but decompressed. In case of no compression on the device,
 * both RawCompressedData and RawData will contain the same data.
 */
using RawData = RawCompressedBlock;

/*--------------------------------------------------------------------------*/

/**
 * Bridge OO pattern I believe. Concrete classes of this interace will be
 * implemented by the users of this library. You could have one that displays
 * timepoints as dots, othe one  that displays squares or solor bars etc.
 */
struct IHintDrawer {};

/**
 * Some additional information coming from an analyzer.
 */
struct IDisplayHint {
        IDisplayHint () = default;
        IDisplayHint (IDisplayHint const &) = default;
        IDisplayHint &operator= (IDisplayHint const &) = default;
        IDisplayHint (IDisplayHint &&) noexcept = default;
        IDisplayHint &operator= (IDisplayHint &&) noexcept = default;
        virtual ~IDisplayHint () = default;

        virtual void draw (IHintDrawer *drw) = 0;
};

/**
 * Single marker on a single (?) channel. If you want to add more than one of thsese
 * consider using TimePoints class for efficiency.
 */
struct TPoint : public IDisplayHint {};

/**
 * Stream of markers.
 */
struct TPoints : public IDisplayHint {};

/**
 *
 */
struct Period : public IDisplayHint {};

using DisplayHints = std::vector<IDisplayHint>;

/*--------------------------------------------------------------------------*/

/**
 * Analyzer output format. This data accompanies the sample data and provides
 * additional, decoded information like binary->hex etc.
 */
struct AugumentedData {
        /// Decoded data
        Buffer data;

        // Additional information about the analyzed data.
        DisplayHints hints;
};

} // namespace logic