/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/constants.hh"
#include <cassert>
#include <chrono>
#include <variant>
#include <vector>
export module logic.data:types;
import logic.core;

export namespace logic {

template <typename T>
concept byte_collection = requires {
        typename T::value_type;
        requires sizeof (typename T::value_type) == 1;
} && std::integral<std::remove_cv_t<typename T::value_type>>;

/// Simply check a boolean variable.
template <typename T>
concept sample_collection = requires (T t) {
        T::SAMPLES;
        requires T::SAMPLES;
};

template <typename T>
concept digital_sample_collection = sample_collection<T> && requires (T t) {
        T::DIGITAL;
        requires T::DIGITAL;
};

/****************************************************************************/

// using TimePoint = std::chrono::high_resolution_clock::time_point;

using Bytes = std::vector<uint8_t>;
using Words = std::vector<uint32_t>;
using Numbers = std::vector<float>;
using Buffer = std::variant<Bytes, Words, Numbers>;

enum class StreamType : uint8_t { digital, analog };

template <typename T, typename Parameter> class NamedType {
public:
        NamedType () = default;
        explicit NamedType (T value) : value_ (std::move (value)) {}

        NamedType (NamedType const &) = default;
        NamedType &operator= (NamedType const &) = default;
        NamedType (NamedType &&) noexcept = default;
        NamedType &operator= (NamedType &&) noexcept = default;
        ~NamedType () = default;

        T &get () { return value_; }
        T const &get () const { return value_; }

private:
        T value_{};
};

/*--------------------------------------------------------------------------*/

using SampleRate = NamedType<uint32_t, struct MySampleRate>;
SampleRate operator""_Sps (unsigned long long x) { return SampleRate (x); }

bool operator== (SampleRate a, SampleRate b) { return a.get () == b.get (); }

/*--------------------------------------------------------------------------*/

template <typename Parameter> class SampleLike : public NamedType<int64_t, Parameter> {
public:
        using Base = NamedType<int64_t, Parameter>;
        using Base::Base;
        SampleLike (int64_t value, SampleRate sampleRate) : Base{value}, sampleRate_{sampleRate} {}

        SampleRate sampleRate () const { return sampleRate_; }

private:
        // Sample rate in samples per second.
        SampleRate sampleRate_ = 1_Sps;
};

template <typename P1, typename P2> void srcheck (SampleLike<P1> const &a, SampleLike<P2> const &b)
{
        if (a.sampleRate () != b.sampleRate ()) {
                throw Exception{"Sample rate mismatch"};
        }
}

// template <typename T> struct IsSampleLike : public std::bool_constant<false> {};
template <template <typename Param> typename S> struct IsSampleLike : public std::bool_constant<false> {};
template <> struct IsSampleLike<SampleLike> : public std::bool_constant<true> {};

template <template <typename Param> typename S>
concept sample_like = IsSampleLike<S>::value;

/*--------------------------------------------------------------------------*/

template <typename P1, typename P2> SampleLike<P1> operator- (SampleLike<P1> const &a, SampleLike<P2> const &b)
{
        srcheck (a, b);
        return SampleLike<P1> (a.get () - b.get (), a.sampleRate ());
}

template <typename P1, typename P2> SampleLike<P1> operator+ (SampleLike<P1> const &a, SampleLike<P2> const &b)
{
        srcheck (a, b);
        return SampleLike<P1> (a.get () + b.get (), a.sampleRate ());
}

template <typename P1, typename P2> SampleLike<P1> &operator+= (SampleLike<P1> &a, SampleLike<P2> const &b)
{
        srcheck (a, b);
        a.get () += b.get ();
        return a;
}

template <typename P1, typename P2> SampleLike<P1> &operator-= (SampleLike<P1> &a, SampleLike<P2> const &b)
{
        srcheck (a, b);
        a.get () -= b.get ();
        return a;
}

/*--------------------------------------------------------------------------*/

using SampleIdx = SampleLike<struct MySampleIdx>;
SampleIdx operator""_SI (unsigned long long value) { return SampleIdx (value); }

using SampleNum = SampleLike<struct MySampleNum>;
SampleNum operator""_Sn (unsigned long long value) { return SampleNum (value); }

/*--------------------------------------------------------------------------*/

template <typename P1, typename P2> bool operator== (SampleLike<P1> const &a, SampleLike<P2> const &b)
{
        return (a.get () == 0 && b.get () == 0) || (a.get () == b.get () && a.sampleRate () == b.sampleRate ());
}

template <typename P1, typename P2> bool operator< (SampleLike<P1> const &a, SampleLike<P2> const &b)
{
        srcheck (a, b);
        return a.get () < b.get ();
}

SampleIdx operator* (SampleIdx const &a, SampleRate b) { return SampleIdx{a.get (), SampleRate (a.sampleRate ().get () * b.get ())}; }
SampleNum operator* (SampleNum const &a, SampleRate b) { return SampleNum{a.get (), SampleRate (a.sampleRate ().get () * b.get ())}; }

template <typename Param> SampleLike<Param> resample (SampleLike<Param> const &a, SampleRate b)
{
        if (a.sampleRate () == b) {
                return a;
        }

        if (a.sampleRate ().get () > b.get ()) {
                uint32_t ratio = a.sampleRate ().get () / b.get ();

                if (a.sampleRate ().get () % b.get ()) {
                        throw Exception{"Resample error"};
                }

                return SampleLike<Param>{a.get () / ratio, b};
        }

        uint32_t ratio = b.get () / a.sampleRate ().get ();

        if (b.get () % a.sampleRate ().get ()) {
                throw Exception{"Resample error"};
        }

        return SampleLike<Param>{a.get () * ratio, b};
}

/*--------------------------------------------------------------------------*/

SampleIdx relativeBegin (SampleIdx index, SampleIdx rangeBegin, size_t zoomOut)
{
        return SampleIdx ((index.get () - rangeBegin.get ()) / zoomOut);
}

SampleIdx relativeEnd (SampleIdx index, SampleIdx rangeBegin, size_t zoomOut)
{
        return SampleIdx (((index.get () - rangeBegin.get ()) / zoomOut) - 1
                          + (((index.get () - rangeBegin.get ()) % zoomOut == zoomOut - 1) ? (1) : (0)));
}

/**
 * The data as received from the device. Possibly compressed with LZ4.
 */
struct RawCompressedBlock {
        double bps{};        /// Debug data indicating bits per second. Not sampling rate.
        size_t overrunsNo{}; /// Number of problems that occured during the reception.
        Bytes buffer;        /// Binary data.

        void clear () { buffer.clear (); }
};

/**
 * The same data but decompressed. In case of no compression on the device,
 * both RawCompressedData and RawData will contain the same data.
 */
using RawData = RawCompressedBlock;

/*--------------------------------------------------------------------------*/

/**
 * Bridge OO pattern I believe. Concrete classes of this interace will be
 * implemented by the users of this library. You could have one that displays
 * timepoints as dots, othe one  that displays squares or solor bars etc.
 */
struct IHintDrawer {};

/**
 * Some additional information coming from an analyzer.
 */
struct IDisplayHint {
        IDisplayHint () = default;
        IDisplayHint (IDisplayHint const &) = default;
        IDisplayHint &operator= (IDisplayHint const &) = default;
        IDisplayHint (IDisplayHint &&) noexcept = default;
        IDisplayHint &operator= (IDisplayHint &&) noexcept = default;
        virtual ~IDisplayHint () = default;

        virtual void draw (IHintDrawer *drw) = 0;
};

/**
 * Single marker on a single (?) channel. If you want to add more than one of thsese
 * consider using TimePoints class for efficiency.
 */
struct TPoint : public IDisplayHint {};

/**
 * Stream of markers.
 */
struct TPoints : public IDisplayHint {};

/**
 *
 */
struct Period : public IDisplayHint {};

using DisplayHints = std::vector<IDisplayHint>;

/*--------------------------------------------------------------------------*/

/**
 * Analyzer output format. This data accompanies the sample data and provides
 * additional, decoded information like binary->hex etc.
 */
struct AugumentedData {
        /// Decoded data
        Buffer data;

        // Additional information about the analyzed data.
        DisplayHints hints;
};

} // namespace logic