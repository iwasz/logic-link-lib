/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <climits>
#include <cstdint>
#include <iterator>

export module logic.data:span.owning;
import :types;

namespace logic {

export template <typename I> class OwningBitSpanSentinel {
public:
        // using BitCarrierT = I::value_type; // Bits are stored in bytes.
        using BitCarrierT = uint8_t; // Bits are stored in bytes.
        static constexpr auto BITS_PER_CARRIER = sizeof (BitCarrierT) * CHAR_BIT;

        using difference_type = std::ptrdiff_t;
        using value_type = bool;

        OwningBitSpanSentinel () = default;
        OwningBitSpanSentinel (size_t bitOffset) : totalBitOffset{bitOffset} {}

        size_t totalBitOffset{};

private:
        // size_t currentElemOffset{};
};

/**
 * TODO requirements for the iterator.
 * TODO consider using this: https://boostorg.github.io/stl_interfaces/doc/html/index.html
 */
export template <typename I> class OwningBitSpanIterator {
public:
        // using BitCarrierT = I::value_type; // Bits are stored in bytes.
        using BitCarrierT = uint8_t; // Bits are stored in bytes.
        static constexpr auto BITS_PER_CARRIER = sizeof (BitCarrierT) * CHAR_BIT;

        using difference_type = std::ptrdiff_t;
        using value_type = bool;

        OwningBitSpanIterator () = default;
        OwningBitSpanIterator (I data, size_t bitOffset) : iter{data}, currentBitOffset{bitOffset % BITS_PER_CARRIER}, totalBitOffset{bitOffset}
        {
                std::ranges::advance (iter, bitOffset / BITS_PER_CARRIER);
        }

        bool operator* () const { return (*iter & BitCarrierT (1 << (BITS_PER_CARRIER - 1 - currentBitOffset))) != 0; }

        OwningBitSpanIterator &operator++ ();
        OwningBitSpanIterator operator++ (int);

        bool operator== (const OwningBitSpanIterator &a) const { return currentBitOffset == a.currentBitOffset && iter == a.iter; }
        template <typename J> bool operator== (const OwningBitSpanSentinel<J> &a) const { return totalBitOffset == a.totalBitOffset; }

private:
        I iter{};
        size_t currentBitOffset{};
        size_t totalBitOffset{};
};

/****************************************************************************/

template <typename I> OwningBitSpanIterator<I> &OwningBitSpanIterator<I>::operator++ ()
{
        ++totalBitOffset;

        if (++currentBitOffset >= BITS_PER_CARRIER) {
                currentBitOffset = 0;
                ++iter;
        }

        return *this;
}

/****************************************************************************/

template <typename I> OwningBitSpanIterator<I> OwningBitSpanIterator<I>::operator++ (int)
{
        auto tmp = *this;
        ++*this;
        return tmp;
}

/**
 * Like bit span, but with copy semantics.
 * TODO this is barely working prove of concept.
 * TODO make it random_access_range and view, and simply use take / drop.
 */
export template <std::ranges::input_range Collection> class OwningBitSpan {
public:
        using BitCarrierT = std::remove_cvref_t<std::ranges::range_reference_t<Collection>>;
        static constexpr auto BITS_PER_CARRIER = sizeof (BitCarrierT) * CHAR_BIT;

        using iterator = OwningBitSpanIterator<std::ranges::iterator_t<Collection>>;
        using const_iterator = OwningBitSpanIterator<std::ranges::const_iterator_t<Collection>>;

        using sentinel = OwningBitSpanSentinel<std::ranges::iterator_t<Collection>>;
        using const_sentinel = OwningBitSpanSentinel<std::ranges::const_iterator_t<Collection>>;

        using value_type = bool;
        using difference_type = std::ptrdiff_t;
        static constexpr bool SAMPLES = true;
        static constexpr bool DIGITAL = true;

        OwningBitSpan () = default;
        OwningBitSpan (Collection data, size_t bitOffset = 0, ssize_t bitSize = -1)
            : data_{std::move (data)},
              offsetInBits{bitOffset},
              sizeInBits{(bitSize < 0)
                                 // Maximum available space when bitSize < 0
                                 ? (std::max<ssize_t> (0, std::ranges::distance (data_) * CHAR_BIT - bitOffset))
                                 // Otherwise bitSize OR the above.
                                 : (std::min<size_t> (bitSize, std::max<ssize_t> (0, std::ranges::distance (data_) * CHAR_BIT - bitOffset)))}
        {
        }

        iterator begin () { return iterator{data_.begin (), offsetInBits}; }
        iterator begin () const { return iterator{std::ranges::begin (const_cast<Collection &> (data_)), offsetInBits}; }

        sentinel end () { return sentinel{offsetInBits + sizeInBits}; }
        sentinel end () const { return sentinel{offsetInBits + sizeInBits}; }

        size_t size () const { return sizeInBits; }
        bool empty () const { return sizeInBits == 0; }

private:
        Collection data_;
        size_t offsetInBits{}; // Starting offset.
        size_t sizeInBits{};
};

} // namespace logic