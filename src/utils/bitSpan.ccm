/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <climits>
#include <cstddef>
#include <iterator>
export module logic:utils;
import :data;

namespace logic::utils {

/**
 * Based on https://en.cppreference.com/w/cpp/iterator/forward_iterator.html
 */
export template <std::unsigned_integral T> class ForwardIterator {
public:
        using difference_type = std::ptrdiff_t;
        using value_type = bool;

        ForwardIterator () = default;
        ForwardIterator (T *data, size_t bitOffset) : data{data}, currentBitOffset{bitOffset} {}

        bool operator* () const;

        ForwardIterator &operator++ ()
        {
                ++currentBitOffset;
                return *this;
        }

        ForwardIterator operator++ (int)
        {
                auto tmp = *this;
                ++*this;
                return tmp;
        }

        bool operator== (const ForwardIterator &a) const { return currentBitOffset == a.currentBitOffset && data == a.data; }

private:
        T *data{};
        size_t currentBitOffset{};
};

static_assert (std::forward_iterator<ForwardIterator<uint8_t>>);

/****************************************************************************/

template <std::unsigned_integral T> bool ForwardIterator<T>::operator* () const
{
        constexpr auto S = sizeof (T) * CHAR_BIT;
        const size_t elemOffset = currentBitOffset / S;
        const size_t bitOffset = S - 1 - (currentBitOffset % S);
        return (*(data + elemOffset) & T (1 << bitOffset)) != 0;
}

/**
 * Semantics like std::span, but iteration happens bit by bit instead of
 * T element after T element. Bits are iterated over in the big endian manner
 * meaning from left to right.
 */
export template <std::unsigned_integral T> class BitSpan {
public:
        // using element_type = T;
        // using value_type = std::remove_cv<T>::type;
        using iterator = ForwardIterator<T>;
        using const_iterator = ForwardIterator<T const>;

        BitSpan (T *data, size_t bitOffset, size_t bitSize) : data{data}, offsetInBits{bitOffset}, sizeInBits{bitSize} {}

        iterator begin () { return {data, offsetInBits}; }
        const_iterator cbegin () const { return {data, offsetInBits}; }

        iterator end () { return {data, offsetInBits + sizeInBits}; }
        const_iterator cend () const { return {data, offsetInBits + sizeInBits}; }

private:
        T *data;
        size_t offsetInBits;
        size_t sizeInBits;
};

} // namespace logic::utils