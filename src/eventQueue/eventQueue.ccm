/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <any>
#include <functional>
#include <mutex>
#include <typeindex>
#include <unordered_map>
export module logic:event.queue;
export import :event;
export import :event.alarm;

namespace logic {

template <typename T>
concept alarm = requires (T t) {
        t.execute (std::any{});
        typename T::Set;
        typename T::Clear;
};

/**
 *
 */
export class EventQueue {
public:
        /// Callbacks are not protected, add from single thread only.
        template <typename T, typename Call> void addCallback (Call &&call)
        {
                eventCallbacks[typeid (T)] = std::any (std::function{std::forward<Call> (call)});
        }

        /// Lock-protected, thread safe.
        template <typename T, typename... Parms> void addEvent (Parms &&...param);
        template <typename T, typename... Parms> void addAlarm (Parms &&...param);
        template <typename T, typename... Parms> void clearAlarm (Parms &&...param);

        /// Lock-protected, thread safe.
        void run ();
        /// Lock-protected, thread safe.
        void waitForEvents ();

private:
        using Pair = std::pair<std::type_index, std::unique_ptr<IEvent>>;
        using Events = std::vector<Pair>;
        using EventCallbacks = std::unordered_map<std::type_index, std::any>;
        using Alarms = std::unordered_map<std::type_index, std::unique_ptr<IAlarm>>;

        void runImpl (Events const &evts);

        Events events;
        EventCallbacks eventCallbacks;
        std::mutex mutex;
        std::condition_variable eventCv;

        Alarms alarms;
        std::condition_variable alarmCv;
};

/****************************************************************************/

void EventQueue::run ()
{
        Events copy;

        {
                std::lock_guard lock{mutex};
                copy = std::move (events);
                events = Events{};
        }

        runImpl (copy);
}

/****************************************************************************/

void EventQueue::waitForEvents ()
{
        Events copy;

        {
                std::unique_lock lock{mutex};
                eventCv.wait (lock, [this] { return !events.empty (); });
                copy = std::move (events);
                events = Events{};
        }

        runImpl (copy);
}

/****************************************************************************/

void EventQueue::runImpl (Events const &evts)
{
        for (auto const &[name, evt] : evts) {
                if (auto i = eventCallbacks.find (name); i != eventCallbacks.cend ()) {
                        auto &callback = eventCallbacks.at (name);
                        evt->execute (callback);
                }
        }
}

/****************************************************************************/

template <typename T, typename... Parms> void EventQueue::addEvent (Parms &&...param)
{
        {
                std::lock_guard lock{mutex};
                events.emplace_back (Pair{typeid (T), std::make_unique<T> (std::forward<Parms> (param)...)});
        }

        eventCv.notify_all ();
}

/****************************************************************************/

template <typename T, typename... Parms> void EventQueue::addAlarm (Parms &&...param)
{
        {
                std::lock_guard lock{mutex};
                auto s = alarms.size ();
                alarms[typeid (T)] = std::make_unique<T> (std::forward<Parms> (param)...);

                if (alarms.size () != s) { // New alarm
                        // addEvent<typename > (std::forward<Parms> (param)...);
                        events.emplace_back (Pair{typeid (T::Set), std::make_unique<T> (std::forward<Parms> (param)...)});
                }
        }

        alarmCv.notify_all ();
        eventCv.notify_all ();
}

/****************************************************************************/

template <typename T, typename... Parms> void EventQueue::clearAlarm (Parms &&...param)
{
        {
                std::lock_guard lock{mutex};
                auto s = alarms.size ();
                alarms.erase (typeid (T));

                if (alarms.size () != s) { // Alarm removed
                        // addEvent<typename T::Clear> (std::forward<Parms> (param)...);
                        events.emplace_back (Pair{typeid (T::Clear), std::make_unique<T> (std::forward<Parms> (param)...)});
                }
        }

        alarmCv.notify_all ();
        eventCv.notify_all ();
}

} // namespace logic