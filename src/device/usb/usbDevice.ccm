/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/error.hh"
#include "common/params.hh"
#include "common/stats.hh"
#include <algorithm>
#include <any>
#include <concepts>
#include <cstdint>
#include <cstdlib>
#include <libusb.h>
#include <vector>
export module logic:usbDevice;
import :usbInput;
import :device;
import :exception;

namespace logic {
export class Session;

/**
 * Helper for sending USB control transfers in a more structured way.
 */
class UsbRequest {
public:
        UsbRequest &clazz (uint32_t c /* = GREATFET_CLASS_LA */) { return integer (c); }
        UsbRequest &verb (uint32_t v) { return integer (v); }
        UsbRequest &sampleRate (uint32_t v) { return integer (v); }
        UsbRequest &channels (uint8_t v) { return integer (v); }
        UsbRequest &size (uint32_t v) { return integer (v); }

        template <std::integral T> UsbRequest &integer (T u)
        {
                data_.resize (data_.size () + sizeof (u));
                uint8_t const *p = reinterpret_cast<uint8_t *> (&u);
                std::copy (p, std::next (p, sizeof (u)), std::prev (data_.end (), sizeof (u)));
                return *this;
        }

        std::vector<uint8_t> const &data () const { return data_; }

private:
        std::vector<uint8_t> data_;
};

/**
 * Parameters speciffic to USB peripherals.
 */
export struct UsbTransmissionParams {
        uint32_t usbTransfer{};
        uint32_t usbBlock{};
        size_t singleTransferLenB{};
        // uint32_t dmaBlock {};
};

export struct UsbInterface {
        int claimInterface{};
        int interfaceNumber{};
        int alternateSetting{};
};

/**
 * Speciffic for **libusb**. Responsible for:
 * - Holds the internal representation (libusb_device_handle *)
 * - Can configure USb class / interface and app-logic stuff (using USB requests).
 * TODO In the future it will also decode received data.
 */
export struct UsbDevice : public IDevice {
public:
        UsbDevice (IInput *input, libusb_device_handle *dev) : dev_{dev}, input_{dynamic_cast<UsbInput *> (input)} {}

        void configureTransmission (std::any const &params) override { configureTransmission (std::any_cast<UsbTransmissionParams> (params)); }
        virtual void configureTransmission (UsbTransmissionParams const &params) { transmissionParams_ = params; }

        void start (Queue<RawCompressedBlock> *queue) override
        {
                input_->start (UsbHandle{.device = this, .queue = queue, .transferLen = transmissionParams_.usbTransfer});
        }

        void stop () override { input_->stop (this); }

        libusb_device_handle const *device () const { return dev_; };
        libusb_device_handle *device () { return dev_; };

protected:
        UsbInput *input () { return input_; }

        /**
         * Basic USB bookeeping like opening thge device, claiming the interface
         * and so on. std::any used to accomodate for all possible busses, not only
         * USB.
         */
        void open (UsbInterface const &info);

        virtual void controlOut (std::vector<uint8_t> const &request);
        virtual void controlOut (UsbRequest const &request) { controlOut (request.data ()); }
        virtual std::vector<uint8_t> controlIn (size_t len);

private:
        libusb_device_handle *dev_{};
        UsbTransmissionParams transmissionParams_;
        UsbInput *input_;
};

} // namespace logic