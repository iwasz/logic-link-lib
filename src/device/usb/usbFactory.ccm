/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <functional>
#include <libusb.h>
#include <memory>
#include <set>
#include <string>
#include <vector>
export module logic:device.factory.usb;
import :device;
import :input.usb;
import :input.demo;
import :event;

namespace logic {

/**
 * Tool for creating UsbDevices.
 *
 * Very curious and sad thing, but I encountered a vscode / debug plugin
 * bug when I had 2 classes called Factory (in different namespaces).
 * It led to some kind of indefinite recurence in liblldb / vgdb vscode
 * plugins and debug adapter crash. LLDB and GDB alone worked OK.
 */
export class UsbFactory {
public:
        UsbFactory (EventQueue *eventQueue);
        UsbFactory (UsbFactory const &) = delete;
        UsbFactory &operator= (UsbFactory const &) = delete;
        UsbFactory (UsbFactory &&) = delete;
        UsbFactory &operator= (UsbFactory &&) = delete;
        ~UsbFactory () = default;

        /**
         * Create an IDevice instance for the first connected USB device or wait.
         */
        std::unique_ptr<IDevice> create () const;

        /**
         * Create a device by name - waits (blocks) if no matching device was connected.
         * If name is empty, delegates to create().
         */
        std::unique_ptr<IDevice> create (std::string const &name) const;

        /**
         * Create a device by vid and pid - waits (blocks) if no matching device was connected.
         */
        std::unique_ptr<IDevice> create (int vid, int pid) const;

        /**
         * Create an USB device from hot-swap event (blocking). It first checks if
         * a simmilar event is active, possibly blocking if it's not. If there's no
         * matching event it will wait for it. If there is one, it creates an IDevice
         * based on that event.
         */
        std::unique_ptr<IDevice> create (UsbConnectedAlarm const *alarm) const;

        /**
         * Returns a list of all detected devices that are currently connected.
         * DOES NOT block.
         */
        std::set<std::string> getConnectedDevices () const;

        UsbAsyncInput &usb () { return usb_; }

        /*
         * Um, this is very USB speciffic, but no other ideas right now.
         */
        std::string vidPidToName (std::pair<int, int> const &vp) const;

private:
        /**
         * All inputs are created here and are shared by all the devices.
         */
        EventQueue *eventQueue_;
        UsbAsyncInput usb_;

        using FactoryFunction = std::function<std::unique_ptr<IDevice> (libusb_device_handle *h)>;

        struct UsbEntry {
                std::string name;
                int vid{};
                int pid{};
                FactoryFunction create;
        };

        std::vector<UsbEntry> usbEntries;

        UsbEntry const *find (int vid, int pid) const;
        UsbEntry const *find (std::string const &name) const;

        // struct DemoEntry {
        //         std::string name;
        //         FactoryFunction create;
        // };

        // std::vector<DemoEntry> demoEntries;
};

}; // namespace logic