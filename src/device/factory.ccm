/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <functional>
#include <memory>
#include <set>
#include <string>
#include <vector>
export module logic:device.factory;
import :device;
import :input.usb;
import :input.demo;
import :event;

namespace logic {

export class Factory {
public:
        Factory (EventQueue *eventQueue);
        Factory (Factory const &) = delete;
        Factory &operator= (Factory const &) = delete;
        Factory (Factory &&) = delete;
        Factory &operator= (Factory &&) = delete;
        ~Factory () = default;

        /**
         * Creates a device of a name `name` - non blocking.
         * - If `name` is empty, creates first detected device (if any).
         * - If `name` is not empty it attempts to create the corresponding device. Returns
         *   nullptr when unsuccessful.
         */
        std::unique_ptr<IDevice> create (std::string const &name);

        /**
         * Create an USB device from hot-swap event.
         */
        std::unique_ptr<IDevice> create (UsbConnectedAlarm const *alarm);

        /**
         * Creates a device of a name `name` - BLOCKING.
         * - If `name` is empty, WAITS for and creates first detected device (if any).
         * - If `name` is not empty it attempts to create the corresponding device. Returns
         *   nullptr when unsuccessful. This scenario desn't block.
         */
        std::unique_ptr<IDevice> wait (std::string const &name);

        /**
         * Returns a list of all detected devices that are currently connected.
         * DOES NOT block.
         */
        std::set<std::string> getConnectedDevices () const;

        // EventQueue &eventQueue () { return eventQueue_; }
        // EventQueue const &eventQueue () const { return eventQueue_; }

        UsbAsync &usb () { return usb_; }
        DemoInput &demo () { return demo_; }

        /*
         * Um, this is very USB speciffic, but no other ideas right now.
         */
        std::string vidPidToName (std::pair<int, int> const &vp) const;

private:
        std::unique_ptr<IDevice> createUsb (int vid, int pid);

        /**
         * All inputs are created here and are shared by all the devices.
         */
        EventQueue *eventQueue_;
        UsbAsync usb_;
        DemoInput demo_;

        std::unique_ptr<IDevice> doCreate (std::string const &name, bool wait);

        using FactoryFunction = std::function<std::unique_ptr<IDevice> (void)>;

        struct UsbEntry {
                std::string name;
                int vid{};
                int pid{};
                FactoryFunction create;
        };

        std::vector<UsbEntry> usbEntries;

        struct DemoEntry {
                std::string name;
                FactoryFunction create;
        };

        std::vector<DemoEntry> demoEntries;
};

}; // namespace logic