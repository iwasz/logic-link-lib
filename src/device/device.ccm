/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include "common/error.hh"
#include "common/params.hh"
#include "common/stats.hh"
#include <algorithm>
#include <any>
#include <concepts>
#include <cstdint>
#include <cstdlib>
#include <unordered_set>
#include <vector>
export module logic:device;
import :input;

namespace logic {
export class Session;

/**
 * IDevice concrete classes are responsible of configuring the devices (for instance
 * by sending USB control requests) and initial decompresing and decoding.
 */
export struct IDevice {
        IDevice () = default;
        IDevice (IDevice const &) = default;
        IDevice &operator= (IDevice const &) = default;
        IDevice (IDevice &&) noexcept = default;
        IDevice &operator= (IDevice &&) noexcept = default;
        virtual ~IDevice () = default;

        /**
         * Request acquisition parameters like number of channels and the
         * sample rate.
         */
        virtual common::acq::Params configureAcquisition (common::acq::Params const &params, bool legacy = false) = 0;

        /**
         * Configure buffer sizes intrinsic to the device - hence the std::any
         * interface. Concreet classes are responsible for converting the argument
         * and using it.
         */
        virtual void configureTransmission (std::any const &params) = 0;

        /**
         * Sets the session and informs an IInput object assigned to this device
         * that the start was requested. Real request gets sent from onStart.
         */
        virtual void start (Session *session) = 0;
        virtual void stop () = 0;
        virtual void run () = 0;

        virtual void onStart () = 0;
        virtual void onStop () = 0;

        /**
         * Get device statistics - speciffic to the device itself and the USB interface.
         * If this was to be a member of the IInput interface, it would have to have better,
         * more generic interface.
         */
        virtual common::usb::Stats getStats () = 0;

        /**
         * Get error list from the device if any.
         */
        virtual std::unordered_set<logs::Code> getErrors () = 0;
        virtual void clearErrors () = 0;
};

/**
 * Basic implementation.
 */
export struct AbstractDevice : public IDevice {
public:
        explicit AbstractDevice (IInput *input) : input_{input} {}

        void start (Session *session) override { input_->start (session); }
        void stop () override { input_->stop (); }
        void run () override { input_->run (); }
        IInput *input () { return input_; }

private:
        IInput *input_;
        // UsbTransmissionParams transmissionParams_;
};

/**
 * Helper for sending USB control transfers in a more structured way.
 */
class UsbRequest {
public:
        UsbRequest &clazz (uint32_t c /* = GREATFET_CLASS_LA */) { return integer (c); }
        UsbRequest &verb (uint32_t v) { return integer (v); }
        UsbRequest &sampleRate (uint32_t v) { return integer (v); }
        UsbRequest &channels (uint8_t v) { return integer (v); }
        UsbRequest &size (uint32_t v) { return integer (v); }

        template <std::integral T> UsbRequest &integer (T u)
        {
                data_.resize (data_.size () + sizeof (u));
                uint8_t const *p = reinterpret_cast<uint8_t *> (&u);
                std::copy (p, std::next (p, sizeof (u)), std::prev (data_.end (), sizeof (u)));
                return *this;
        }

        std::vector<uint8_t> const &data () const { return data_; }

private:
        std::vector<uint8_t> data_;
};

/**
 * Parameters speciffic to USB peripherals.
 */
export struct UsbTransmissionParams {
        uint32_t usbTransfer{};
        uint32_t usbBlock{};
        size_t singleTransferLenB{};
        // uint32_t dmaBlock {};
};

/**
 *
 */
export struct AbstractUsbDevice : public AbstractDevice {
public:
        using AbstractDevice::AbstractDevice;

        void configureTransmission (std::any const &params) override { configureTransmission (std::any_cast<UsbTransmissionParams> (params)); }
        virtual void configureTransmission (UsbTransmissionParams const &params) { transmissionParams_ = params; }
        virtual size_t transferLen () const { return transmissionParams_.usbTransfer; }
        void controlOut (UsbRequest const &request) { input ()->controlOut (request.data ()); }

private:
        UsbTransmissionParams transmissionParams_;
};

} // namespace logic