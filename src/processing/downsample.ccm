/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <climits>
#include <concepts>
#include <cstdint>
#include <cstdlib>
#include <format>
#include <ranges>
#include <span>
export module logic.processing:downsample.digital;
import logic.data;
import logic.core;

namespace logic {

template <std::unsigned_integral auto BITS> struct WordType {};

template <> struct WordType<8UL> {
        using type = uint8_t;
};
template <> struct WordType<16UL> {
        using type = uint16_t;
};

/****************************************************************************/

template <std::integral auto factor, byte_collection Collection> struct Downsample {};

template <byte_collection Collection> struct Downsample<2, Collection> {
        static constexpr size_t BITS = 2;
        static Collection operator() (Collection const &in, uint8_t *state);
};

template <byte_collection Collection> struct Downsample<4, Collection> {
        static constexpr size_t BITS = 4;
        static Collection operator() (Collection const &in, uint8_t *state);
};

template <std::integral auto factor, byte_collection Collection>
        requires requires { requires factor == 8 || factor == 16; }
struct Downsample<factor, Collection> {
        static constexpr size_t BITS = factor;
        using WordT = WordType<BITS>::type;
        static Collection operator() (Collection const &in, uint8_t *state);
};

/**
 * Factory/helper function.
 */
template <std::integral auto factor, byte_collection Collection> Collection downsample (Collection const &in, uint8_t *state)
{
        return Downsample<factor, Collection>::operator() (in, state);
}

namespace impl {
        template <byte_collection Collection, int N, int... Ns> Collection downsample (Collection const &in, size_t zoomOut, uint8_t *state)
        {
                if (zoomOut == N) {
                        return logic::downsample<N> (in, state);
                }

                if constexpr (sizeof...(Ns) > 0) {
                        return impl::downsample<Collection, Ns...> (in, zoomOut, state);
                }

                throw Exception{std::format ("Zoom level: {} not allowed.", zoomOut)};
        }
} // namespace impl

export namespace pop {
        template <byte_collection Collection> Collection downsample (Collection const &in, size_t zoomOut, uint8_t *state)
        {
                static constexpr std::integer_sequence<int, 2, 4, 8, 16> allowedZoomLevels2;

                auto lbd = [&in, zoomOut, state]<int... Ns> (std::integer_sequence<int, Ns...> const & /* alwd */) {
                        return impl::downsample<Collection, Ns...> (in, zoomOut, state);
                };

                return lbd (allowedZoomLevels2);
        }
} // namespace pop

Bytes downsample2 (Bytes const &in, uint8_t *state);
Bytes downsample4 (Bytes const &in, uint8_t *state);
Bytes downsample8 (Bytes const &in, uint8_t *state);

export namespace lut {
        Bytes downsample (Bytes const &in, size_t zoomOut, uint8_t *state);
}

/****************************************************************************/

template <byte_collection Collection> Collection Downsample<2, Collection>::operator() (Collection const &in, uint8_t *state)
{
        if (in.size () % BITS) {
                throw logic::Exception{std::format ("in.size ()[{}] % {} != 0", in.size (), BITS)};
        }

        Collection out;
        out.reserve (in.size () / BITS);

        auto last = [state] (int bits) mutable -> bool {
                if (bits == BITS / 2) {
                        bits = int (!bool (*state));
                        *state = bits; // Flipping back and forth
                }

                return bool (bits);
        };

        for (auto [a, b] : in | std::views::adjacent<2> | std::views::stride (2)) {
                int bit7 = last (std::popcount (uint8_t (a & 0b11000000)));
                int bit6 = last (std::popcount (uint8_t (a & 0b00110000)));
                int bit5 = last (std::popcount (uint8_t (a & 0b00001100)));
                int bit4 = last (std::popcount (uint8_t (a & 0b00000011)));

                int bit3 = last (std::popcount (uint8_t (b & 0b11000000)));
                int bit2 = last (std::popcount (uint8_t (b & 0b00110000)));
                int bit1 = last (std::popcount (uint8_t (b & 0b00001100)));
                int bit0 = last (std::popcount (uint8_t (b & 0b00000011)));

                out.push_back (bit7 << 7 | bit6 << 6 | bit5 << 5 | bit4 << 4 | bit3 << 3 | bit2 << 2 | bit1 << 1 | bit0 << 0);
        }

        return out;
}

/****************************************************************************/

template <byte_collection Collection> Collection Downsample<4, Collection>::operator() (Collection const &in, uint8_t *state)
{
        if (in.size () % BITS) {
                throw logic::Exception{std::format ("in.size ()[{}] % {} != 0", in.size (), BITS)};
        }

        Collection out;
        out.reserve (in.size () / BITS);

        auto last = [state] (int bits) mutable -> bool {
                if (bits == 3) {
                        bits = int (!bool (*state));
                        *state = bits; // Flipping back and forth
                }

                return bool (bits);
        };

        for (auto [a, b, c, d] : in | std::views::adjacent<4> | std::views::stride (4)) {
                int bit7 = last (std::popcount (uint8_t (a & 0b11110000)));
                int bit6 = last (std::popcount (uint8_t (a & 0b00001111)));
                int bit5 = last (std::popcount (uint8_t (b & 0b11110000)));
                int bit4 = last (std::popcount (uint8_t (b & 0b00001111)));

                int bit3 = last (std::popcount (uint8_t (c & 0b11110000)));
                int bit2 = last (std::popcount (uint8_t (c & 0b00001111)));
                int bit1 = last (std::popcount (uint8_t (d & 0b11110000)));
                int bit0 = last (std::popcount (uint8_t (d & 0b00001111)));

                out.push_back (bit7 << 7 | bit6 << 6 | bit5 << 5 | bit4 << 4 | bit3 << 3 | bit2 << 2 | bit1 << 1 | bit0 << 0);
        }

        return out;
}

/****************************************************************************/

template <std::integral auto factor, byte_collection Collection>
        requires requires { requires factor == 8 || factor == 16; }
Collection Downsample<factor, Collection>::operator() (Collection const &in, uint8_t * /* state */)
{
        if (in.size () % BITS) {
                throw logic::Exception{std::format ("in.size ()[{}] % {} != 0", in.size (), BITS)};
        }

        Collection out;
        out.reserve (in.size () / BITS);

        size_t cnt = CHAR_BIT - 1;
        WordT outB{};
        auto inSp = std::span<WordT const>{reinterpret_cast<WordT const *> (in.data ()), in.size () / (BITS / CHAR_BIT)};

        for (WordT inB : inSp) {
                outB |= int (std::popcount (inB) >= BITS / 2) << cnt;

                if (cnt-- == 0) {
                        out.push_back (outB);
                        outB = 0;
                        cnt = CHAR_BIT - 1;
                }
        }

        return out;
}

} // namespace logic