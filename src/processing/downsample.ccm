/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <bitset>
#include <climits>
#include <cmath>
#include <concepts>
#include <cstdint>
#include <cstdlib>
#include <format>
#include <ranges>
#include <span>
export module logic.processing:downsample.digital;
import logic.data;
import logic.core;

namespace logic {

template <std::unsigned_integral auto BITS> struct WordType {};

template <> struct WordType<8UL> {
        using type = uint8_t;
};
template <> struct WordType<16UL> {
        using type = uint16_t;
};

export {
        template <std::integral auto factor, byte_collection Collection> struct Downsample {};

        template <byte_collection Collection> struct Downsample<2, Collection> {
                static constexpr size_t BITS = 2;
                static Collection operator() (Collection const &in, bool *state);
        };

        template <byte_collection Collection> struct Downsample<4, Collection> {
                static constexpr size_t BITS = 4;
                static Collection operator() (Collection const &in, bool *state);
        };

        template <std::integral auto factor, byte_collection Collection>
                requires requires { requires factor == 8 || factor == 16; }
        struct Downsample<factor, Collection> {
                static constexpr size_t BITS = factor;
                using WordT = WordType<BITS>::type;
                static Collection operator() (Collection const &in, bool *state);
        };

        /**
         * Factory/helper function.
         */
        template <std::integral auto factor, byte_collection Collection> Collection downsample (Collection const &in, bool *state)
        {
                return Downsample<factor, Collection>::operator() (in, state);
        }
}

namespace impl {
        template <byte_collection Collection, int N, int... Ns> Collection downsample (Collection const &in, size_t zoomOut, bool *state)
        {
                if (zoomOut == N) {
                        return logic::downsample<N> (in, state);
                }

                if constexpr (sizeof...(Ns) > 0) {
                        return impl::downsample<Collection, Ns...> (in, zoomOut, state);
                }

                throw Exception{std::format ("Zoom level: {} not allowed.", zoomOut)};
        }
} // namespace impl

export template <byte_collection Collection> Collection downsample (Collection const &in, size_t zoomOut, bool *state)
{
        static constexpr std::integer_sequence<int, 2, 4, 8, 16> allowedZoomLevels2;

        auto lbd = [&in, zoomOut, state]<int... Ns> (std::integer_sequence<int, Ns...> const & /* alwd */) {
                return impl::downsample<Collection, Ns...> (in, zoomOut, state);
        };

        return lbd (allowedZoomLevels2);
}

/****************************************************************************/

template <byte_collection Collection> Collection Downsample<2, Collection>::operator() (Collection const &in, bool *state)
{
        if (in.size () % BITS) {
                throw logic::Exception{std::format ("in.size () % {} != 0", BITS)};
        }

        Collection out;
        out.reserve (in.size () / BITS);

        auto last = [state] (int bits) mutable -> bool {
                if (bits == 1) {
                        bits = !(*state);
                        *state = bits; // Flipping back and forth
                        // bits = std::rand () & 1; // TODO benchmark this https://stackoverflow.com/questions/26237419/faster-than-rand
                }

                return bool (bits);
        };

        for (auto [a, b] : in | std::views::adjacent<2> | std::views::stride (2)) {
                int bit7 = last (std::popcount (uint8_t (a & 0b11000000)));
                int bit6 = last (std::popcount (uint8_t (a & 0b00110000)));
                int bit5 = last (std::popcount (uint8_t (a & 0b00001100)));
                int bit4 = last (std::popcount (uint8_t (a & 0b00000011)));

                int bit3 = last (std::popcount (uint8_t (b & 0b11000000)));
                int bit2 = last (std::popcount (uint8_t (b & 0b00110000)));
                int bit1 = last (std::popcount (uint8_t (b & 0b00001100)));
                int bit0 = last (std::popcount (uint8_t (b & 0b00000011)));

                out.push_back (bit7 << 7 | bit6 << 6 | bit5 << 5 | bit4 << 4 | bit3 << 3 | bit2 << 2 | bit1 << 1 | bit0 << 0);
        }

        return out;
}

/****************************************************************************/

template <byte_collection Collection> Collection Downsample<4, Collection>::operator() (Collection const &in, bool * /* state */)
{
        if (in.size () % BITS) {
                throw logic::Exception{"in.size () % BITS"};
        }

        Collection out;
        out.reserve (in.size () / BITS);

        size_t cntOut = BITS - 1;
        uint8_t outB{};

        for (uint8_t b : in) {
                std::bitset<8> b1{size_t (b & 0b11110000)};
                std::bitset<8> b2{size_t (b & 0b00001111)};

                if (cntOut == 3) {
                        outB |= int (b1.count () > 2) << 7 | int (b2.count () > 2) << 6;
                        --cntOut;
                }
                else if (cntOut == 2) {
                        outB |= int (b1.count () > 2) << 5 | int (b2.count () > 2) << 4;
                        --cntOut;
                }
                else if (cntOut == 1) {
                        outB |= int (b1.count () > 2) << 3 | int (b2.count () > 2) << 2;
                        --cntOut;
                }
                else {
                        outB |= int (b1.count () > 2) << 1 | int (b2.count () > 2) << 0;
                        out.push_back (outB);
                        outB = 0;
                        cntOut = BITS - 1;
                }
        }

        return out;
}

/****************************************************************************/

template <std::integral auto factor, byte_collection Collection>
        requires requires { requires factor == 8 || factor == 16; }
Collection Downsample<factor, Collection>::operator() (Collection const &in, bool * /* state */)
{
        if (in.size () % BITS) {
                throw logic::Exception{"in.size () % BITS"};
        }

        Collection out;
        out.reserve (in.size () / BITS);

        size_t cnt = CHAR_BIT - 1;
        WordT outB{};
        auto inSp = std::span<WordT const>{reinterpret_cast<WordT const *> (in.data ()), in.size () / (BITS / CHAR_BIT)};

        for (WordT inB : inSp) {
                outB |= int (std::popcount (inB) >= BITS / 2) << cnt;

                if (--cnt == 0) {
                        out.push_back (outB);
                        outB = 0;
                        cnt = CHAR_BIT - 1;
                }
        }

        return out;
}

/****************************************************************************/

export struct State {
        bool prevEvenAvg = false;

        void clear () { prevEvenAvg = false; }
};

/**
 * Downsample digital samples. Doesn't validate input length. Naiive implementation.
 *
 * @param begin Skip this number of samples (bits)
 * @param inputSize In samples (bits).
 * @param outSampleNum In samples (bits).
 * @deprecated description
 */
export template <typename byte_collection>
        requires requires { typename byte_collection::value_type; }
&& std::same_as<std::remove_cv_t<typename byte_collection::value_type>, uint8_t>
Bytes downsample (byte_collection const &in, SampleIdx begin, SampleNum inputSize, logic::SampleNum outSampleNum, State *state)
{
        using BitHoldingT = Bytes::value_type;
        static constexpr size_t BITS = sizeof (BitHoldingT) * CHAR_BIT;

        float ratio = float (inputSize) / float (outSampleNum);

        Bytes ret;
        ret.reserve (std::ceil (float (outSampleNum) / BITS));

        float bitCnt{};
        int cntIn{};
        int setBits{};

        BitHoldingT outWord{};
        int cntOut = BITS - 1;

        for (BitHoldingT inWord : in) {
                for (int i = BITS - 1; i >= 0; --i) {
                        if (begin > 0) {
                                --begin;
                                continue;
                        }

                        setBits += int ((inWord & (1 << i)) != 0);
                        bitCnt += 1.0F;
                        ++cntIn;

                        if (bitCnt >= ratio) {
                                bool avg = bool (std::round (float (setBits) / cntIn));

                                // If exactly half of the bits are set, we have to round it up and down interchangeably.
                                if (setBits * 2 == cntIn) {
                                        state->prevEvenAvg = avg = !state->prevEvenAvg;
                                }

                                outWord |= (avg) ? (1 << cntOut) : (0);

                                if (cntOut-- <= 0) {
                                        cntOut = BITS - 1;
                                        ret.push_back (outWord);
                                        outWord = 0;
                                }

                                setBits = 0;
                                cntIn = 0;
                                bitCnt -= ratio;
                        }
                }
        }

        return ret;
}

} // namespace logic