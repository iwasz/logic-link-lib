/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <format>
#include <ranges>
module logic.processing;
import logic.data;

namespace logic {

/**
 * With flipping and LUT. Should work the same as the `Downsample<2, Collection>::operator()`
 */
Bytes downsample3 (Bytes const &in, bool *state)
{
        static constexpr size_t BITS = 2;

        if (in.size () % BITS) {
                throw logic::Exception{std::format ("in.size ()[{}] % {} != 0", in.size (), BITS)};
        }

        using Lut0 = std::array<uint8_t, std::numeric_limits<uint8_t>::max () + 1>;
        using Lut1 = std::array<Lut0, 2>;

        // Both LUTs generated using lutD2_f
        static constexpr Lut1 lut = {
                Lut0{
                        0,  1,  1,  1,  2,  2,  2,  3,  2,  2,  2,  3,  2,  3,  3,  3,  4,  4,  4,  5,  4,  5,  5,  5,  4,  5,  5,  5,  6,
                        6,  6,  7,  4,  4,  4,  5,  4,  5,  5,  5,  4,  5,  5,  5,  6,  6,  6,  7,  4,  5,  5,  5,  6,  6,  6,  7,  6,  6,
                        6,  7,  6,  7,  7,  7,  8,  8,  8,  9,  8,  9,  9,  9,  8,  9,  9,  9,  10, 10, 10, 11, 8,  9,  9,  9,  10, 10, 10,
                        11, 10, 10, 10, 11, 10, 11, 11, 11, 8,  9,  9,  9,  10, 10, 10, 11, 10, 10, 10, 11, 10, 11, 11, 11, 12, 12, 12, 13,
                        12, 13, 13, 13, 12, 13, 13, 13, 14, 14, 14, 15, 8,  8,  8,  9,  8,  9,  9,  9,  8,  9,  9,  9,  10, 10, 10, 11, 8,
                        9,  9,  9,  10, 10, 10, 11, 10, 10, 10, 11, 10, 11, 11, 11, 8,  9,  9,  9,  10, 10, 10, 11, 10, 10, 10, 11, 10, 11,
                        11, 11, 12, 12, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 14, 14, 14, 15, 8,  9,  9,  9,  10, 10, 10, 11, 10, 10, 10,
                        11, 10, 11, 11, 11, 12, 12, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 14, 14, 14, 15, 12, 12, 12, 13, 12, 13, 13, 13,
                        12, 13, 13, 13, 14, 14, 14, 15, 12, 13, 13, 13, 14, 14, 14, 15, 14, 14, 14, 15, 14, 15, 15, 15,
                },
                Lut0{
                        0,  0,  0,  1,  0,  1,  1,  1,  0,  1,  1,  1,  2,  2,  2,  3,  0,  1,  1,  1,  2,  2,  2,  3,  2, 2,  2,  3,  2,
                        3,  3,  3,  0,  1,  1,  1,  2,  2,  2,  3,  2,  2,  2,  3,  2,  3,  3,  3,  4,  4,  4,  5,  4,  5, 5,  5,  4,  5,
                        5,  5,  6,  6,  6,  7,  0,  1,  1,  1,  2,  2,  2,  3,  2,  2,  2,  3,  2,  3,  3,  3,  4,  4,  4, 5,  4,  5,  5,
                        5,  4,  5,  5,  5,  6,  6,  6,  7,  4,  4,  4,  5,  4,  5,  5,  5,  4,  5,  5,  5,  6,  6,  6,  7, 4,  5,  5,  5,
                        6,  6,  6,  7,  6,  6,  6,  7,  6,  7,  7,  7,  0,  1,  1,  1,  2,  2,  2,  3,  2,  2,  2,  3,  2, 3,  3,  3,  4,
                        4,  4,  5,  4,  5,  5,  5,  4,  5,  5,  5,  6,  6,  6,  7,  4,  4,  4,  5,  4,  5,  5,  5,  4,  5, 5,  5,  6,  6,
                        6,  7,  4,  5,  5,  5,  6,  6,  6,  7,  6,  6,  6,  7,  6,  7,  7,  7,  8,  8,  8,  9,  8,  9,  9, 9,  8,  9,  9,
                        9,  10, 10, 10, 11, 8,  9,  9,  9,  10, 10, 10, 11, 10, 10, 10, 11, 10, 11, 11, 11, 8,  9,  9,  9, 10, 10, 10, 11,
                        10, 10, 10, 11, 10, 11, 11, 11, 12, 12, 12, 13, 12, 13, 13, 13, 12, 13, 13, 13, 14, 14, 14, 15,
                },
        };

        static constexpr Lut1 lutS = {
                Lut0{
                        0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0,
                        1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1,
                        1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1,
                        0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0,
                        1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0,
                        1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0,
                        0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0,
                },
                Lut0{
                        1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,
                        0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0,
                        0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0,
                        1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1,
                        0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1,
                        0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1,
                        1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1,
                },

        };

        Bytes out (in.size () / BITS);
        auto &s = *state;

        std::ranges::copy (in | std::views::adjacent_transform<2> ([&s] (uint8_t a, uint8_t b) -> uint8_t {
                                   uint8_t outb = lut[s][a] << 4;
                                   s = lutS[s][a];

                                   outb |= lut[s][b];
                                   s = lutS[s][b];
                                   return outb;
                           }) | std::views::stride (2),
                           out.begin ());

        // "Manual" implementatio is order of magnitude faster under -O0 which simetimes can be helpful for debugging.
        // for (size_t i = 0; auto &ch : out) {
        //         uint8_t a = in[i * 2];
        //         uint8_t b = in[i * 2 + 1];
        //         ch = lut[*state][a] << 4;
        //         *state = lutS[*state][a];

        //         ch |= lut[*state][b];
        //         *state = lutS[*state][b];
        // }

        return out;
}

} // namespace logic