/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <climits>
#include <cstdint>
#include <ranges>
#include <vector>
export module logic.processing:poly;
import logic.data;

namespace logic {

/**
 * All comments from the function above this one apply. But this one expects
 * a collection of bits (bools).
 */
export template <typename Coord, digital_sample_collection Collection>
std::vector<Coord> toPolyPointsb (Collection const &data, bool *lastBit, Coord h, Coord lineWidth, Coord padding)
{
        if (data.empty ()) {
                return {};
        }

        Coord x = padding * lineWidth;
        std::vector<Coord> ret;
        ret.reserve (data.size () * 2);

        // Starting point.
        ret.push_back (x);
        ret.push_back ((*lastBit) ? (0) : (h));

        for (uint8_t bit : data) {
                // edge
                if (*lastBit != bit) {
                        ret.push_back (x);
                        ret.push_back ((bit) ? (0) : (h));
                }

                // level
                x += lineWidth;

                ret.push_back (x);
                ret.push_back ((bit) ? (0) : (h));

                *lastBit = bit;
        }

        return ret;
}

/**
 * First bit is used only for the edge rendering. No level corresponding to
 * the first bit will be rendered. This is to make seamless tiles possible,
 * where we need to start from a known state rendered before. For instance
 * if a tile on the left finished with HI state, and the next (current) tile
 * starts with tle LO state, we need to draw a level â†“. But how are supposed
 * to know that? This is why src/PlotView/digitalSamplesTile.cc peeks one
 * bit before, and this functions uses it to draw corresponding level.
 */
export template <typename Coord, digital_sample_collection Collection>
std::vector<Coord> toPolyPointsb (Collection const &data, Coord h, Coord lineWidth, Coord padding)
{
        if (data.empty ()) {
                return {};
        }

        bool lastBit = *data.begin ();

        Coord x = padding * lineWidth;
        std::vector<Coord> ret;
        ret.reserve (data.size () * 2);

        // Starting point.
        ret.push_back (x);
        ret.push_back ((lastBit) ? (0) : (h));

        for (uint8_t bit : data | std::views::drop (1)) {
                // edge
                if (lastBit != bit) {
                        ret.push_back (x);
                        ret.push_back ((bit) ? (0) : (h));
                }

                // level
                x += lineWidth;

                ret.push_back (x);
                ret.push_back ((bit) ? (0) : (h));

                lastBit = bit;
        }

        return ret;
}

export struct PolyPointsCfg {
        /// Height in points.
        float height{};

        /// In points.
        float lineWidth{};

        /// Empty space before thestart of the plot.
        logic::SampleNum paddingS{};

        /// Maximum number of samples that can be displayed without blening one with another as a result of zoom-out.
        // size_t discernibleSamples{};

        /// To maintain seamless plot betwen the tiles we get 1 bit before our range to see how the signal changed.
        bool continuation{};
};

/**
 *
 */
export template <typename Coord, digital_sample_collection Collection>
std::vector<Coord> toPolyPointsb2 (Collection const &data, PolyPointsCfg const &cfg)
{
        if (data.empty ()) {
                return {};
        }

        bool lastBit = *data.begin ();

        Coord x = float (cfg.paddingS) * cfg.lineWidth;
        std::vector<Coord> ret;
        // Just to be sure. there are 2 line segments for every sample for square wave.
        auto dataSize = data.size () - int (cfg.continuation);
        ret.reserve (dataSize * 4);

        // Starting point. Continuation from the prevbious iteration.
        if (cfg.continuation) {
                ret.push_back (x);
                ret.push_back ((lastBit) ? (0) : (cfg.height));
        }

        // auto ratio = double (dataSize) / double (cfg.discernibleSamples);
        // std::println ("dataSize: {}, discernible: {}, ratio: {}", dataSize, cfg.discernibleSamples, ratio);

        for (uint8_t bit : data | std::views::drop (int (cfg.continuation))) {
                // edge
                if (lastBit != bit) {
                        ret.push_back (x);
                        ret.push_back ((bit) ? (0) : (cfg.height));
                }

                // level
                x += cfg.lineWidth;

                ret.push_back (x);
                ret.push_back ((bit) ? (0) : (cfg.height));

                lastBit = bit;
        }

        return ret;
}

/**
 * "Draws" a binary data sterem as a poly line. Returns the coordinates as a vector of Coord (int,
 * float, etc). Data order is x0, y0, x1, y1 etc. ~~The w parameter is the limit (no vertices past
 * this point gets generated~~, h is the vertical stretch). Input data is expected to be a
 * collection of unsigned integers of arbitrary size. Every such word is then converted bit by bit.
 *
 * TODO If level does not change, no points shall be added, but rather the resulting line
 * shall be prolonged! For example if I call this with data collection containig 256 bytes
 * of value 0, this function shall output only 2 vertices instead od 2048 as it does currently!
 *
 * TODO The does not stand if we display the individual samples as dots.
 * @deprecated
 */
export template <typename Coord, typename Collection> std::vector<Coord> toPolyPointsW (Collection &&data, PolyPointsCfg const &cfg)
{
        // if (std::ranges::empty (data)) {
        //         return {};
        // }

        Coord x = 0;
        std::vector<Coord> ret;
        // ret.reserve (data.size () * CHAR_BIT);

        // bool lastBit = *data.begin () & 0b1000'0000;
        bool lastBit = false;

        // Starting point.
        if (cfg.continuation) {
                ret.push_back (0);
                ret.push_back ((lastBit) ? (0) : (cfg.height));
        }

        // bool clipped = false;

        for (uint8_t byte : data) {
#if 0
                if (cnt == 0 || cnt == data.size () - 1) {
                        std::print ("{:0b},", byte);
                }
                ++cnt;
#endif

                for (int i = CHAR_BIT - 1; i >= 0; --i) {
                        bool bit = (byte & (1 << i));

#if 0
                        ret.push_back (x);
                        ret.push_back ((bit) ? (0) : (cfg.height));
                        ret.push_back (x);
                        ret.push_back ((bit) ? (5) : (cfg.height - 5));
                        ret.push_back (x);
                        ret.push_back ((bit) ? (0) : (cfg.height));
#endif
                        // edge
                        if (lastBit != bit) {
                                ret.push_back (x);
                                ret.push_back ((bit) ? (0) : (cfg.height));
                        }

                        // level
                        x += cfg.lineWidth;

                        // if (x >= w) { // Clipping
                        //         x = std::min (x, w); // Clip the plot if necesarry
                        //         i = -1;              // Make this iteration the last one
                        //         clipped = true;      // Break the outer loop as well
                        // }

                        ret.push_back (x);
                        ret.push_back ((bit) ? (0) : (cfg.height));

                        lastBit = bit;
                }

                // if (clipped) {
                //         // For now I simply print a "warning". The clipping is undesirable.
                //         // std::println ("C");
                //         break;
                // }
        }

        return ret;
}

/****************************************************************************/

export template <typename PolyCollection> void scalePolyPoints (PolyCollection *data, double scaleX, double scaleY)
{
        // TODO how to achieve this with views? *data = *data | std::views::stride (2) | std::views::adjacent<2> (adj) ;

        size_t cnt{};
        for (auto &el : *data) {
                el *= (cnt++ % 2 == 0) ? (scaleX) : (scaleY);
        }
}

} // namespace logic