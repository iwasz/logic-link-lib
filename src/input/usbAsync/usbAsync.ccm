/****************************************************************************
 *                                                                          *
 *  Author : lukasz.iwaszkiewicz@gmail.com                                  *
 *  ~~~~~~~~                                                                *
 *  License : see COPYING file for details.                                 *
 *  ~~~~~~~~~                                                               *
 ****************************************************************************/

module;
#include <any>
#include <atomic>
#include <cstdint>
#include <cstdlib>
#include <functional>
#include <libusb.h>
#include <vector>
export module logic:input.usb;
export import :input;
export import :event;

namespace logic {
export class Session;
export class AbstractUsbDevice;

export class UsbConnectedAlarm : public AbstractAlarm {
public:
        explicit UsbConnectedAlarm (libusb_device_handle *devHandle, libusb_device_descriptor *desc)
            : devHandle_{devHandle}, vid_{desc->idVendor}, pid_{desc->idProduct}
        {
        }

        void execute (std::any const &func) const override
        {
                auto f = std::any_cast<std::function<void (UsbConnectedAlarm const *)>> (func);
                f (this);
        }

        std::size_t hash () const override { return std::hash<std::size_t>{}(size_t (devHandle_)); }

        int vid () const { return vid_; }
        int pid () const { return pid_; }
        libusb_device_handle *devHandle () { return devHandle_; };

private:
        /*
         * Im using this raw type, becasue this is the concrete alarm, so it pertains only
         * USB devices. Second, this pointer is a definite way of telling two connected USB
         * devices apart. If you connect 2 identical USB devices VID and PID is not enough.
         */
        libusb_device_handle *devHandle_{};
        int vid_{};
        int pid_{};
};

/**
 * @brief
 *
 */
export struct UsbDeviceInfo {
        int vid{};
        int pid{};
        int claimInterface{};
        int interfaceNumber{};
        int alternateSetting{};
};

/**
 *
 */
export class UsbAsync : public AbstractInput {
public:
        /**
         * Construct a new UsbAsync object and initializes the libusb.
         */
        UsbAsync (EventQueue *eventQueue);
        UsbAsync (UsbAsync const &) = delete;
        UsbAsync &operator= (UsbAsync const &) = delete;
        UsbAsync (UsbAsync &&) noexcept = delete;
        UsbAsync &operator= (UsbAsync &&) noexcept = delete;

        /**
         * Gracefully de-inits the libusb.
         */
        ~UsbAsync () override;

        std::any open (std::any const &info) override;

        void controlOut (std::vector<uint8_t> const &request) override;
        std::vector<uint8_t> controlIn (size_t len) override;

        void start (Session *session) override;
        void stop () override { request_.store (Request::stop); }
        void run () override;
        void kill () override { request_.store (Request::kill); }

private:
        static void transferCallback (struct libusb_transfer *transfer);
        static int hotplugCallback (struct libusb_context * /* ctx */, struct libusb_device *dev, libusb_hotplug_event event, void *userData);

        static void handleUsbEvents (int *completed, int timeoutS, libusb_transfer *transfer);
        static void handleUsbEventsCompleted (int *completed, libusb_transfer *transfer);
        static void handleUsbEventsTimeout (int timeoutMs, libusb_transfer *transfer);

        enum class Request : uint8_t { none, start, stop, kill };
        enum class State : uint8_t { disconnected, connectedIdle, transferring };

        // TODO This is the biggest flaw! This makes this class work only for single device!
        libusb_device_handle *dev{};
        libusb_hotplug_callback_handle callback_handle{};

        std::atomic<Request> request_;
        std::atomic<State> state_;
        Session *session{};
        AbstractUsbDevice *device{};

        // TODO.
        /// Number of bytes received so far irrespective of the buffer size.
        // size_t receivedB () const { return allTransferedB; }
        // std::mutex mutex;
        // TimePoint globalStart;
        // TimePoint globalStop;
        // size_t allTransferedB{};
};

} // namespace logic